
本章主要讲解Pytest框架在接口自动化、Web UI自动化、App UI自动化项目中的实践和落地。本章采用分层模型加基于模块的框架结构，混合了接口自动化测试框架、Web UI自动化测试框架以及App UI自动化测试框架的实现。演示了，框架各种需求如何实现，如何分层和规划框架结构，如何封装实用方法及业务操作等等各项内容。
## 8.1  测试框架基本需求
在搭建测试框架之前，首先我们要弄清楚为什么要搭建测试框架，测试框架能为团队带了什么样的实际意义？以及搭建测试框架需要满足哪些需求，具有哪些功能？这样才能决定如何架构、选型和解决各种问题，并带来实际的收益。
### 8.1.1  搭建测试框架的意义和价值
自动化测试的意义在于快速验证、回归以及线上巡检。相比于开发测试平台、测试工具，自动化测试（特别是接口自动化），是比较容易快速成型及产生价值的。
由于自动化测试同样基于代码（也会有自身的Bug），同时往往需要多人协作，因此也需要合理的代码组织架构，以及一定的规范。相比于一堆测试脚本，搭建测试框架的意义可以简单梳理为以下几点：
 1. 基础模块及业务封装，避免重复开发，提高自动化测试用例编写效率；
 2. 合理的封装和设计，是编写用例更简单，代码量更少；
 3. 为用例编写、调试、挑选、批量运行、日志及测试报告等提供完整的解决方案；
 4. 用例风格较为统一，减少后期维护成本；
因此在开展自动化测试框架之前进行合理的规划架构测试框架是非常有必要的。
搭建测试框架一般有两种思路，一种是顶层设计，即从需求出发，先规划好结构逻辑，封装各个公共模块再进行使用。另一种则是由测试脚本逐步优化，封装，分离，来逐渐完成测试框架的结构，不过这种也需要在项目前期完成，当用例极累了很多时，调整起来的成本是很大的。
### 8.1.2  测试框架的基本需求
搭建和设计测试框架，需要实现哪些需求呢？首先从软件（代码）项目来说，一般都包含以下部分：
- 代码：程序（框架）的核心逻辑，一般包含多个模块；
- 配置：通过修改配置和在不改变代码的情况下灵活的满足不同的需求；
- 数据/资源：程序运行需要的一些外部数据或资源，用户可以随时更换；
- 日志：程序一般都具有日子的功能，方便调试及定位问题。
测试框架作为自动化测试项目的基础，也应该满足上面的基本需求。另外测试框架作为“为解决自动化测试”问题而设计的一种架构，一般还需要满足以下需求：
1. 提供用例编写、调试、运行、日志、测试报告等完整的解决方案；
2. 可以挑选用例批量运行，并生成测试报告；
3. 稳定运行并提供清晰的出错提示及运行日志；
4. 支持CI（持续集成），提供命令行运行方式；
5. 逻辑清楚，上手简单，编写用例方便快捷（只需要关注业务逻辑）；
6. 提供用例标签、优先级、用例分类、测试套件等灵活的用例组织方式；
7. 支持灵活的配置和多环境切换；
8. UI自动化还需要解决不稳定用例的问题等；
9. 并发及运行效率问题。
当然，以上需求只是常见的一部分，不同的项目根据实际需要可能具有不同的需求和偏重。
### 8.1.3  测试框架选型及解决方案
在测试框架选型时，“效益（快速成型并可用）”是非常重要的。在自动化测试项目中，相比于Java语言，Python更加简单易用，测试人员受众面更广，功能测试人员通过简单培训便可快速上手。
在Python测试框架中，Pytest无疑是目前最为流行的测试框架之一，同时简单易用，功能齐全并方便定制，同时拥有非常丰富的插件，可以快速满足我们落地测试框架的各种需求。一些常见的解决方案如下：
 1. 日志：使用Python自带logging库输出日志，使用Pytest配置文件配置日志格式；
 2. 测试报告：使用pytest-html或allure-pytest插件生成测试报告；
 3. 批量运行及CI支持：Pytest原生支持命令行挑选用例运行；
 4. 灵活的标记用例组织方式：Pytest原生支持支持按用例列表、用例目录、用例标记、用例名称格式运行用例，安装pytest-level、pytest-owner等插件还支持按用例等级、用例归属人运行；
 5. 多环境切换：使用pytest-ini支持配置多个环境的变量并切换，或使用插件pytest-base-url及pytest-variables通过命令行参数根据环境切换服务地址及所使用的数据文件；
 6. 不稳定用例处理：使用pytest-rerunfailures可以在用例失败后自动重试多次，来处理用例不稳定问题，同时pytest-timeout插件可以为用例设置执行超时时间，防止用例卡死。
除了极为丰富的插件意外，使用Pytest测试框架我们还可以根据项目的实际需求，来方便的添加自定义参数及配置，以及使用钩子函数对Pytest运行流程进行定制修改，实现各种需求。
### 8.1.4  分层框架简介
代码的组织往往需要一定的结构，分层结构是软件架构中是最常用的一种架构方式。如Android的4层架构、Web开发框架中的MVC模型。分层结构将软件分外若干层，每一层只处理一部分问题，封装操作并向上提供调用方法。
如同8.1所示，一种典型的分层结构，数据层负责底层数据的读取，并为上层供操作方法。业务层使用数据层的方法封装业务操作，并为表示层提供可调用的方法。表示层使用业务层的方法处理用户交互。
图8.1 典型分层结构模型
分层结构的一个典型特点是“单项依赖”，上层依赖下层（需要用到下层的方法），下层不依赖上层。比如数据层操作应具有业务无关性，即应该也可以在其他类似项目中使用，并且数据层的方法应足够灵活已适用不同的项目。
在测试框架中，使用分层架构能提供清晰良好的封装调用逻辑。
## 8.2  接口测试框架实践
由于Pytest及requests库非常易用，我们基本只需要使用session完成接口授权，并封装一些常用操作即可。
### 8.2.1  项目简介
Monica是一款基于PHP+MySQL开发的开源个人关系管理软件，支持多种语言。可以用于管理联系人及记录结识、交流等过程并设置联系提醒。界面如图8.2所示：
项目地址：https://github.com/monicahq/monica。
图8.2  Monica联系人详情界面
1. 安装Monica
基于Docker的安装方式如下，其他安装安装方式参考：
https://github.com/monicahq/monica/blob/main/docs/installation/readme.md
 1. 安装并启动Docker；
 2. 在命令行运行以下命令；
```bash
mysqlCid="$(docker run -d \
 -e MYSQL_RANDOM_ROOT_PASSWORD=true \
 -e MYSQL_DATABASE=monica \
 -e MYSQL_USER=homestead \
 -e MYSQL_PASSWORD=secret \
 -p 3306:3306 mysql:5.7)"
docker run -d --link "$mysqlCid":mysql -e DB_HOST=mysql -p 8080:80 monica
```

> 注意：需要当前主机8080或3306端口已被占用，可以修改上面命令中映射的端口号。

 3. 等待1-3分钟后，打开浏览器访问http://localhost:8080，如图8.3所示：
图8.3  Monica初始化页面
 4. 注册账号并登录，便可进行使用。
 5. 注册并自动登录后，可以点击顶部菜单栏右侧的设置图标，在账户设置中找到布局，将名称顺序修改为`<Last name> <First name>`这种姓+名的中国人姓名的这种习惯方式。
2. Monica接口说明

Monica官方提供完整的接口文档，基于本地服务，接口文档可以参考：
https://www.monicahq.com/api，如图8.4所示。

图8.4  Monica接口文档

首先我们要在Monica中设置一个用于访问接口的个人访问令牌。登录Monica后，点击右上角的设置图标，点击左侧菜单的API，点击创建密钥按钮，输入一个Token名称，点击创建，如图8.5所示：

图8.5  设置接口访问令牌

复制并保存生成的Token字符串。（如果不小心原来的Token遗忘了，可以生成一个新的Token使用）。
在接口请求中安装OAuth2.0的方式使用Token，即在请求Headers中添加：
```
Authorization: Bearer 你的Token字符串
```
以查询联系人接口为例，Postman中使用方式如图8.6所示：

图8.6  Postman使用令牌访问本地服务查询联系人接口

### 8.2.2  搭建测试框架目录结构
在搭建测试框架前需要考虑需要满足哪些测试需求及测试框架具有哪些特性（功能）。对于接口测试项目，我们一般需要满足以下需求：
- 接口封装；
- 支持数据库段断言；
- 支持切换测试环境和使用的用户；
- 漂亮的测试报告；
- 支持发送测试报告邮件；
这里我们使用类及继承来封装业务接口，使用pymysql来支持数据库操作及断言、使用pytest-ini插件来支持切换测试环境和使用的用户、使用allure-pytest插件来生成漂亮的测试报告。使用自己封装的发送邮件的实用方法来实现发送邮件功能。
搭建测试框架往往并不是一次成型，而是一个渐进完善的过程，最简单的测试框架只需要安装一些三方包及依赖，对测试框架简单定制加上用例层即可，框架结构如图8.6所示。
图8.7  接口测试框架基本结构

> 注：该分层结构是一个初步的规划状态，后面的章节会对其进行完善和补充

在测试框架中，我们一般使用目录来组织不同的内容，如测试用例、数据、日志、测试报告等，另外还需要有配置文件、依赖列表、项目说明等。最简单的框架基本接口如图8.7所示。
打开PyCharm新建项目，并手动创建以下目录及文件：
- testcases：测试用例目录
- utils：实用方法库目录
- tools：allure命令行工具等
- data：测试数据目录
- reports：测试报告目录
- logs：测试日志目录
- conftest.py：编写Fixtures函数及框架定制
- pytest.ini：项目配置
- requirements.txt：依赖三方包列表
- README.md：项目说明文件
### 8.2.3  三方包及项目依赖
搭建框架我们需要使用到一些三方库及插件等。需要本次框架需要用到的三方库及插件如下：
- requests：用于发送HTTP请求；
- pytest：Pytest框架；
- pyyaml：用于读取YAML文件数据；
- pymysql：用于操作MySQL数据库；
- allure-pytest：用于生成Allure测试报告数据；
- pytest-timeout：用于为用例设置统一的超时时间；
- pytest-level：用于标记用例优先级；
- pytest-owner：用于标记用例归属；
- pytest-check：用于支持复合断言（断言失败后继续检查其他断言）；
- pytest-faker：用于生成各种测试数据；
- pytest-ini：复用pytest.ini支持多环境及全局变量配置；
- pytest-xdist：多进程并发运行测试用例；
除了自己使用pip命令逐个安装好各个依赖的三方库以外，我们还要清晰的把这些所依赖的三方库记录下来，以方便在其他机器搭建测试框架环境，以及其他人使用时知道需要安装哪些依赖。
在Python项目中，我们一般使用“requirements.txt”文件来列出项目所需依赖，例如：
文件requirements.txt内容
```txt
requests
pytest
pyyaml
pymysql
allure-pytest
pytest-timeout
pytest-level
pytest-owner
pytest-check
pytest-faker
pytest-ini
pytest-xdist
```
用户在安装时只需要在requirements.txt同级目录的命令行使用以下命令，便可以安装所有依赖：
```bash
pip install -r requirements.txt
```

> 注：如果安装依赖时遇到Retry....的报错（连不上pypi仓库）导致安装不了可以使用豆瓣源安装，命令如下：
```
pip install -r requirements.txt -i https://pypi.doubanio.com/simple/
```
### 8.2.4  项目配置及相关Fixtures
我们使用Pytest.ini作为测试框架的全部配置，同时使用Pytest-ini插件我们还可以添加很多自定义配置。
#### 基本配置及标记规划
在项目实践中，常用的配置有默认参数addopts、用例路径testpaths以及自定义标记markers等。
虽然在非严格模式下，Pytest中允许用用例添加任何自定义标记，但是没有固定的规划会导致标记的混乱，不知道用例中使用了哪些标记。因此，在框架中我们一般推荐使用严格模式，并提前规划好可以使用的标记。
自定义标记的规划因人而异，这里提供一些标记规划的示例：
- @pytest.mark.pvt：标记冒烟用例（一小批通过性用例）；
- @pytest.mark.neg：即negative，标记异常场景用例；
- @pytest.mark.des：即destructive，标记破坏性的用例（对场景配置进行修改可能影响到其他用例执行的用例）；
- @pytest.mark.bugverify：标记Bug验证及回归用例；
- @pytest.mark.slow：标记运行时间比较长的用例；
- @pytest.mark.query：标记查询类用例，查询类用例一般具有非破坏性；
用户可以根据实际需求，比如需要特定模式、特定权限来增加新的标记。自定义标记在pytest.ini中配置方式如下：
```ini
[pytest]
addopts = -v --strict-markers
testpaths = testcases
markers =
 pvt: Process verification tests (smoke tests)
 neg: Negative tests (abnormal tests)
 des: Destructive tests (tests which may destroy the environment)
 bugverify: Tests for verify bugs
 slow: Tests which run above 30s
```

> 注意：标记和标记说明之间用的是英文冒号。

更多的配置可以参考7.6.2 配置文件小节。
#### 日志等级及格式配置
在实际使用是，日志等级和配置可以灵活调整，输出到屏幕及输出到日志文件也可以分别设置，参考配置如下：
```ini
[pytest]
# ... ...
log_file = logs/autotest.log
log_file_level = DEBUG
log_file_format = [%(asctime)s] [%(levelname)s] [%(filename)s->%(funcName)s:L%(lineno)d] %(message)s
log_file_date_format = %Y%m%d %H:%M:%S
log_cli = True
log_cli_level = INFO
log_cli_format = [%(asctime)s] [%(levelname)s] [%(filename)s->%(funcName)s:L%(lineno)d] %(message)s
log_cli_date_format = %Y%m%d %H:%M:%S
```
日志等级及日志格式等也可以根据实际的需求进行调整。
3.三方插件及多环境配置
```ini
[pytest]
addopts = -v --strict-markers --alluredir=reports/allure-data
# ......
timeout = 30
env = test
[test]
base_url = http://localhost:8080
token = <填写你的Monica个人令牌>
db_host = localhost
db_port = 3306
db_user = homestead
db_password = secret
db_name = monica
```
其中--aluredir=reports/allure-data用于指定Allure测试报告数据目录，需要安装allure-pytest插件timeout来自于插件pytest-timeout，用于配置每个用例执行的超时时间。超时时间的作用时防止用例长时间没有结束导致执行卡死。
env配置来自于插件pytest-ini，用于配置当前所使用的测试环境（配置段），即当前使用`[test]`段的所有配置，如果有其他环境或者全局变量，也可以添加如`[prod]`、`[global]`段的配置。
当前环境`[test]`中，base_url用于配置当前环境基础服务地址，token用于授权（其他项目可以配置为user和password变量来用于授权）。由于数据库一般跟环境有关，所以我们把数据库配置也放到了当前环境中，db_host、db_port、db_user、db_password和db_name分别代表数据库服务器地址、端口号、用户名、密码、及使用的数据库名称；
#### 邮件及自定义参数配置
我们在框架中规划了发送邮件的功能，就要对发送邮件的账户密码及发送邮件主题、内容及收件人等进行配置。借助pytest-ini插件，我们在pytest.ini中添加其他额外的段[smtp]及`[email]`来分别配置发送邮件账户及邮件内容，同时我们还需要添加一个自定义命令行参数可--send-email来控制运行完是否发送邮件，参考配置如下。
```ini
[pytest]
addopts = -v --strict-markers --aluredir=reports/allure-data --send-email
# ...
[smtp]
smtp_server = <你的邮箱SMTP服务器>
smtp_user = <你的邮箱地址>
smtp_port = 25
smtp_password = <你的邮箱授权码>
enable_ssl = False
[email]
email_subject = Api Test Report
email_receivers = <收件人列表，英文逗号隔开>
email_body = <h2>Api Test Report</h2>
  Test run completed, please refer to the attrachements for details.
```
其中--send-email是我们自定义的参数，需要我们使用钩子函数添加该参数。
SMTP配置中，smtp_server是邮件服务器，可以登录自己的邮箱，在设置中开通SMTP服务，并查看具体地址。smtp_user是邮箱用户，一般要加上完整的后缀。smtp_password指邮箱授权码，在开通SMTP服务时会动态生成。smtp_port为SMTP服务端口号（一般不开启SSL时默认为25，开启SSL时默认为465），enable_ssl为是否开启SSL安全传输，默认为False，可以根据需求添加相应的选项来修改配置。
Email配置中email_subject指邮件主题，email_receivers指收件人、多个收件人用英文逗号隔开，email_body指邮件内容，支持HTML格式。INI配置文件中支持多行文本，新的行向右缩紧，则视为同属于上一个变量内容。
> 注意：在Windows系统中pytest.ini中默认只支持英文（包括注释），因此建议使用全英文配置。

完整项目配置如下：
> 文件pytest.ini内容
```ini
[pytest]
addopts = -v --strict-markers --alluredir=reports/allure-data
testpaths = testcases
markers =
 pvt: Process verification tests (smoke tests)
 neg: Negative tests (abnormal tests)
 des: Destructive tests (tests which may destroy the environment)
 bugverify: Tests for verify bugs
 slow: Tests which run above 30s

log_file = logs/%Y%m%d_%H%M%S.log
log_file_level = DEBUG
log_file_format = [%(asctime)s] [%(levelname)s] [%(filename)s->%(funcName)s:L%(lineno)d] %(message)s
log_file_date_format = %Y%m%d %H:%M:%S
log_cli = True
log_cli_level = INFO
log_cli_format = [%(asctime)s] [%(levelname)s] [%(filename)s->%(funcName)s:L%(lineno)d] %(message)s
log_cli_date_format = %Y%m%d %H:%M:%S
timeout = 30
env = test

[test]
base_url = http://localhost:8080
token = <填写你的Monica个人令牌>
db_host = localhost
db_port = 3306
db_user = homestead
db_password = secret
db_name = monica

[smtp]
smtp_server = <你的邮箱SMTP服务器>
smtp_user = <你的邮箱地址>
smtp_port = 25
smtp_password = <你的邮箱授权码>
enable_ssl = False

[email]
email_subject = Api Test Report
email_receivers = <收件人列表，英文逗号隔开>
email_body = <h2>Api Test Report</h2>
  Test run completed, please refer to the attrachements for details.
```
4.相关Fixtures方法实现
我们可以将环境配置中的，常用参数如base_url、token等做成Fixure函数，已方便用例直接适用相关配置。在系统根目录conftest.py中添加如下代码：
```python
import pytest

@pytest.fixture()
def base_url(env_vars):
    """返回pytest.ini指定环境中的base_url变量，需要安装pytest-ini"""
    return env_vars.get('base_url')
@pytest.fixture()
def token(env_vars):
    """返回pytest.ini指定环境中的token变量，需要安装pytest-ini"""
    return env_vars.get(token)
@pytest.fixture
def db_conf(env_vars):
    """返回pytest.ini指定环境中的数据库配置，需要安装pytest-ini"""
    host = env_vars.get('db_host')
    port = env_vars.get('db_port')
    user = env_vars.get('db_user')
    password = str(env_vars.get('db_password'))
    db = env_vars.get('db_name')
    return dict(host=host, port=port, user=user, password=password, db=db)
```
其中env_vars是pytest-ini插件提供的Fixture方法，是一个ChainMap类型，包含所有当前指定环境的所有变量、global配置的所有全局变量，以及系统环境变量os.envion所有的值，如果三者中有同名变量，优先级为当前环境变量>全局变量>系统环境变量。
### 8.2.5  日志文件绝对路径及动态文件名
在pytest.ini中配置了日志文件的相对路径logs/run.log，这个相对位置是相对于运行起始位置的，如果在用例目录testcases中运行，日志就会输出到testcases/logs/run.log中，当然我们希望日志应该输出到项目根目录的logs目录中，这就需要通过钩子函数（Hooks)来修改log_file路径为绝对路径。在项目根目录的conftest.py中我们可以使用钩子函数pytest_configure来修改配置，具体实现代码如下：
```python
def pytest_configure(config):
    """Pytest初始化配置钩子函数"""
    root_dir = config.rootpath  # 获取项目根目录
    # 获取pytest.ini文件中的log_file配置项
    log_file = config.getini('log_file')
    if log_file: # 如果存在该配置项
        # 修改命令行选项中的log-file参数为日志绝对路径
        config.option.log_file = rootdir / log_file
```
我们可以更进一步，是log_file的配置支持根据时间生成动态文件名，例如，我们可以使用datetime的striftime根据字符串格式化时间来实现。
```python
from datetime import datetime

NOW = datetime.now()
print(NOW.stripftime('%Y%m%d_%H%M%S.log'))
```
将得到根据时间生成的动态文件名，如“20220425_110234.log”。其中%Y、%m、%d、%H、%M、%S分别代表当前年、月、日、时、分、秒。
修改pytest.ini中日志文件的配置如下：
```ini
[pytest]
# ...
og_file = logs/%Y%m%d_%H%M%S.log
修改conftest.py中pytest_configure函数的内容如下：
from datetime import datetime
NOW = datetime.now()
def pytest_configure(config):
    """Pytest初始化配置钩子函数"""
    root_dir = config.rootpath  # 获取项目根目录
    # 获取pytest.ini文件中的log_file配置项
    log_file = config.getini('log_file')
    if log_file: # 如果存在该配置项2
        # 修改命令行选项中的log-file参数为日志绝对路径
        config.option.log_file = root_dir / NOW.strftime(log_file)
```
同时修改pytest.ini文件中log_file的配置为
```
log_file = logs/%Y%m%d_%H%M%S.log
```
运行某个带日志输出的用例便会发现用例，日志文件输出为按秒输出，这样每运行一次便会生成一个新的日志文件。

> 注：用户也可以根据自己的需求配置日志格式，也支持log_file中不带时间占位符来生成固定的日志文件。
### 8.2.6  自动生成Allure报告
同样，由于运行时--alluredir参数使用的是相对路径，为了避免调试用例时，测试报告数据目录生成出错，我们同样需要将其修改为绝对路径。
实现方式如下：
一般情况下，生成Allure测试数据后我们还需要手动使用Allure命令行工具，将报告转为HTML报告才能查看，我们可以使用Pytest的钩子方法来实现，命令行运行后自动将报告转为HTML报告。在修改项目目录conftest.py代码如下如下：
```python
import platform
import os

def pytest_configure(config: pytest.Config):
    """用于修改pytest配置"""
    root_dir = config.rootpath  # 获取项目根目录
    # ...省略日志绝对路径配置
    # 处理allure报告路径
    alluredir = config.getoption("--alluredir")
    if alluredir is not None:
        config.option.allure_report_dir = root_dir / alluredir
        
def pytest_terminal_summary(terminalreporter, exitstatus, config: pytest.Config):
    """运行后的命令行总结"""
    if config.getoption("--alluredir") is not None:
        if 'Windows' in platform.platform():
            allure = config.rootpath / 'tools/allure-2.18.1/bin/allure.bat'
        else:
            allure = config.rootpath / 'tools/allure-2.18.1/bin/allure'
        allure_data = config.option.allure_report_dir
        allure_html = config.rootpath / 'reports/allure-html'
        os.system('%s generate %s -o %s' % (allure, allure_data, allure_html))
        print('allure html报告生成成功')
```

> 注意：这里使用来命令行总结这个钩子方法，该方法在命令行使用pytest命令执行用例时才会触发，在PyCharm中直接右键运行不会触发该方法的执行。

上面使用到的Allure命令行工具，需要手动下载并解压如allure-2.18并放置在项目tools目录下，这里还使用platform模块根据当前系统来自动选择使用allure.bat还是allure可执行文件。
另外实际在使用Jenkins进行持续集成时，不需要我们自己生成报告，Jenkins对应的Allure插件可以自动生成HTML测试报告以供查看。
## 8.3  实用方法层封装
实用方法是框架中一些常用的方法封装，如组装路径、读取数据文件、操作数据库、编码转换以及一些三方库的基本封装。由于直接和底层数据打交道，在某些框架也称为数据层或序列化层。
实用方法层有一个关键的特性是“业务无关性”，即应不包含具体的业务操作，已便适用于任何同类型项目。
实用方法层中的封装根据实际项目需要进行补充，如有的项目需要进行加密/解密即编码转换，有的需要用到Redis或MongoDB，就可以根据需求，把用到的方法归类封装一个个实用方法模块。
### 8.3.1  路径实用方法封装
由于项目被用户克隆或下载后，有可能在任意路径下运行的。在项目中，无论模块的导入还是数据文件的读取，我们都需要知道准确的模块和文件路径。这就要求我们首先计算出当前项目所在的路径，然后按照项目的结构得到数据等目录的实际路径。
在代码中的模块导入都从项目根目录查找进行导入，这样只需要保证项目根目录被导入到模块寻找路径中即可。
路径实用方法的分层封装逻辑如图8.8所示

图8.8  路径实用方法分层封装逻辑
#### 项目路径实用方法
在utils目录中新建path_utils.py,内容如下：
文件utils/path_utils.py内容
```python
from pathlib import Path

# 项目根目录, __file__指当前文件
PROJECT_ROOT = Path(__file__).parent.parent 
# 测试数据目录
DATA_DIR = PROJECT_ROOT / 'data' 
```


这里用到Python的一个魔术变量__file__，这个变量代表当前文件即path_utils.py的路径。我们使用Python自带的pathlib库将当前文件路径得到一个路径（Path）对象。路径对象的.parent方法可以得到其上级路径。当前文件的上级路径即utils文件夹，utils文件夹再上一级就是项目根目录。
得到项目根目录后，项目中其他目录的路径可以按框架的结构得出。Path对象得到下级路径的方式为, Path / '子目录',多层就接着写。
如果熟悉使用os.path模块的话也可以用os.path模块实现，示例如下：
```python
import os
# 项目根目录, __file__指当前文件
PROJECT_ROOT = os.path.dirname(os.path.dirname(__file__))
# 测试数据目录
DATA_DIR = os.path.join(PROJECT_ROOT, 'data')
...
```

其中，os.path.dirname()为获取上级路径，os.path.join()为根据当前系统路径分割符，进行路径连接，即得到下级路径。
#### 对应Fixture方法实现
我们可以将这些路径封装称Fixtures方法，以方便用户使用，在根目录conftest.py中添加代码如下：
```python
from utils.path_utils import PROJECT_ROOT, DATA_DIR
@pytest.fixture()
def project_root():
    """项目根目录"""
    return PROJECT_ROOT
@pytest.fixture()
def data_dir():
    """数据目录"""
    return DATA_DIR
我们也可以使用request这个Pytest内置的Fixture函数拿到project_root，并基于该Fixture函数组装得到data_dir，实现代码如下：
@pytest.fixture()
def project_root(request):
    return request.config.rootpath
def data_dir(project_root):
   return project_root / 'data'
```

> 注意：三方插件pytest-datadir提供了自动发现测试数据目录的类似功能，也可以直接安装使用该插件（但是无法在用例及Fixture函数外使用）。

用例中可以使用data_dir这个Fixture函数快速获取到数据文件的绝对路径，例如，假设项目data中存在数据文件“data.txt”，用例中使用该文件的方式如下：
```python
def test_use_data_file(data_dir):
    file_path = data_dir / 'data.txt'  # 快速得到该文件的绝对路径，不容易出错
    print(file_path)
```
虽然路径配置的Fixture函数并不需要path_utils模块的变量即可使用，但是仍建议该模块。原因是普通函数无法使用Fixture函数，例如数据驱动模式如下：
```python
from utils.path_utils import DATA_DIR

@pytest.mark. parametrize('line', open(DATA_DIR / 'data.txt')
def test_ddt_with_data_file(line):
    print(line)
```
这样就方便在无法使用Fixture函数的场合也能快速组装出所需要的绝对路径。
### 8.3.2  数据文件实用方法封装
测试数据也成为“测试资源”。为了方便维护，框架中一般需要将测试数据和测试用例进行分离，以便在业务变化或环境调整时可以只更换数据而无需修改用例代码。
根据不同的业务类型，我们可以选择不同的数据文件，常用的数据及配置文件类型如下：
- TXT: 分行数据, 无结构的文本数据，适用于大段文本或简单的单列数据；
- CSV/TSV：表格型数据，适合大量同一类型的数据；
- EXCEL：表格型数据，多表格，构造数据方便, 非纯文本，文件较大，解析较慢；
- JSON：树形数据，可以存储多层数据, 格式严格,不支持备注，适用于配置文件或接口请求等需要多层嵌套等数据；
- YAML：树形数据，兼容JSON, 灵活,可以存储多层数据，适用于配置文件或接口请求等需要多层嵌套等数据，有一定学习成本；
- XML：树形数据，可以存储多层, 文件格式教繁琐，适用于配置文件或接口请求等需要多层嵌套等数据；
- TOML：树行数据，类似于INI，适用于配置文件；
- INI：两层型数据，可以按段存储不同的变量值, 适合配置文件。
除Python自带的处理纯文本文件的open函数和json、csv、xml、configparser库来处理JSON、CSV/TSV、XML、INI文件之外，其他类型文件我需要用到如下一些三方库。
- YAML文件解析：PyYAML库，可以通过命令pip install pyyaml进行安装；
- Excel文件解析：Openpyxl库或Xlrd库，可以通过命令pip install openpyxl或pip install xlrd进行安装；
- TOML文件解析：Toml库，可以通过命令pip install toml进行安装。
实际上，框架并不需要封装所有类型数据文件的操作，只需要根据业务选择所需要的数据文件类型即可。
由于大部分情况下，我们只需要读取测试数据，我们这里只封装文件的读取操作。我们将所有需要使用到的文件的读取操作都集中到一个名为FileUtils的类中，以方便使用。
数据文件实用方法分层封装逻辑如图8.9所示：

图8.9  数据实用方法分层封装逻辑
#### 读取及加载纯文本文件
读取纯文本文件非常简单，只要打开并读取返回文件的全部内容即可。与“读取”返回一大段无结构的字符串数据不同，“加载”一般指将文件内容转换成一种结构化的数据，如列表、字典或一种类的对象。这种结构话的数据可以方便用户提取不同字段的值。
纯文本文件的读取及加载示例如下：
```python
import logging
class FileUtils:
    def read(self, file_path, encoding='utf-8'):
        """读取纯文本文件全部内容"""
        logging.debug('读取文本文件: %s' % file_path)
        with open(file_path, 'r' ,encoding=encoding) as f:
            return f.read()
    def load_txt(self, file_path, encoding='utf-8'):
        """读取txt文件并得到每一数据组成的列表"""
        logging.debug('加载TXT文件: %s' % file_path)
        with open(file_path, 'r', encoding=encoding) as f:
            return [row.strip() for row in f.readlines()]
```

在load_text中，为了得到txt文件中每一列数据组成的列表，我们用strip()去掉了每一行数据末尾的换行符。
假设有示例数据文件内容如下：
文件data.txt内容
```txt
张三
李四
王五
```
使用FileUitls().load_text('data.txt')得到的结果如下：
```
['张三', '李四', '王五']
```
#### 加载树型数据JSON、YAML文件
JSON、YAML都是树型结构的数据，打开文件并用对应的load方法可以很方便的将其中的数据转为字典或列表。参考封装代码如下：
```python
import yaml
import toml

class FileUtils:
    def load_json(self, file_path, encoding='utf-8'):
        """加载json文件并转为字典或列表，如果json文件不合法，会报JSONDecodeError"""
        logging.debug('加载JSON文件: %s' % file_path)
        with open(file_path, 'r', encoding=encoding) as f:
            return json.load(f)
    def load_yaml(self, file_path, encoding='utf-8'):
        """加载yml文件并转为字典或列表，需要安装PyYAML"""
        logging.debug('加载YAML文件: %s' % file_path)
        with open(file_path, 'r', encoding=encoding) as f:
            return yaml.safe_load(f)
```
> 注意：在load_yaml中使用了safe_load()方法，该方法只加载基本的变量类型，而不加载Python对象类型。

假如我们有示例数据文件内容如下：

> 文件data.json内容
```json
{
  "zhangsan": {
    "name": "张三",
    "age": "16",
    "hobbies": [
      "篮球",
      "轮滑",
      "围棋"
    ]
  }
}
```

> 文件data.yml内容
```yaml
zhangsan:
  name: 张三
  age: 16
  hobbies:
    - 篮球
    - 轮滑
    - 围棋
```

分别使用FileUtils().load_json('data.json')、FileUtils().load_yaml('data.yml')加载后内容如下：
```python
{'zhangsan': {'name': '张三', 'age': 16, 'hobbies': ['篮球', '轮滑', '围棋']}}
```
#### 加载表格型数据CSV文件
表格型数据分为带标题行和不带标题行，对于带标题行，我们每一行数据和对应的标题组成的字典格式，不带标题行的我们每一行数据返回一个元祖或者列表。参考封装代码如下：
```python
import csv

class FileUtils:       
    def load_csv(self, file_path, encoding='utf-8', sep=",", with_header=True):
        """加载csv文件，并返回列表，默认文件带标题行with_header=True"""
        logging.debug('加载CSV文件: %s' % file_path)
        data = []
        with open(file_path, 'r', encoding=encoding) as f:
            if with_header is True:
                reader = csv.DictReader(f, delimiter=sep)
            else:
                reader = csv.reader(f, delimiter=sep)
            for row in reader:
                data.append(row)
        return data
```
在load_csv中我们添加了分隔符sep参数来支持tsv文件，如果带标题行，我们使用DictReader来将每一行数据读取为字典格式。不带标题行则使用默认的reader读取为列表格式。
加入有如下示例数据文件：
文件data.csv内容
```csv
name,age,score
张三,16,87
李四,17,92
王五,16,77
```
文件data.tsv内容
```tsv
name age  score
张三  16    87
李四  17    92
王五  16    77
```
使用`FileUtils().load_csv('data.csv')`得到的数据如下：

```python
[{'name': '张三', 'age': 16, 'score': 87}, {'name': '李四', 'age': 17, 'score': 92}, {'name': '王五', 'age': 16, 'score': 77}]
```

#### 根据文件后缀加载文件
为了方便使用，我们可以封装一个统一的load方法，根据文件扩展名自动选择对应的方法，参考封装如下：
```python
   def load(self, file_path, **kwargs):
        """加载任意支持的数据文件"""
        file_path = str(file_path)  # 将Path类型转为路径字符串
        if file_path.endswith('.txt'):
            return self.load_txt(file_path, **kwargs)
        elif file_path.endswith('.csv'):
            return self.load_csv(file_path, **kwargs)
        elif file_path.endswith('.json'):
            return self.load_json(file_path, **kwargs)
        elif file_path.endswith('.yml') or file_path.endswith('.yaml'):
            return self.load_yaml(file_path, **kwargs)
        else:
            raise NotImplementedError('不支持该文件类型')
```
如果不是所支持的类型则抛出NotImplementedError未实现异常。完整代码如下：
> 代码utils/file_utils.py内容
```python
import logging
import json
import csv
import yaml

class FileUtils:
    def read(self, file_path, encoding='utf-8'):
        """读取纯文本文件全部内容"""
        logging.debug('读取文本文件: %s' % file_path)
        with open(file_path, 'r', encoding=encoding) as f:
            return f.read()
            
    def load_txt(self, file_path, encoding='utf-8'):
        """读取txt文件并得到每一数据组成的列表"""
        logging.debug('加载TXT文件: %s' % file_path)
        with open(file_path, 'r', encoding=encoding) as f:
            return [row.strip() for row in f.readlines()]
            
    def load_json(self, file_path, encoding='utf-8'):
        """加载json文件并转为字典或列表，如果json文件不合法，会报JSONDecodeError"""
        logging.debug('加载JSON文件: %s' % file_path)
        with open(file_path, 'r', encoding=encoding) as f:
            return json.load(f)
            
    def load_yaml(self, file_path, encoding='utf-8'):
        """加载yml文件并转为字典或列表，需要安装PyYAML"""
        logging.debug('加载YAML文件: %s' % file_path)
        with open(file_path, 'r', encoding=encoding) as f:
            return yaml.safe_load(f)
            
    def load_csv(self, file_path, encoding='utf-8', delimiter=",", with_header=True):
        """加载csv文件，并返回列表，默认文件带标题行with_header=True"""
        logging.debug('加载CSV/TSV文件: %s' % file_path)
        data = []
        with open(file_path, 'r', encoding=encoding) as f:
            if with_header is True:
                reader = csv.DictReader(f, delimiter=delimiter)
            else:
                reader = csv.reader(f, delimiter=delimiter)
            for row in reader:
                data.append(row)
        return data
        
    def load(self, file_path, **kwargs):
        """加载任意支持的数据文件"""
        file_path = str(file_path)  # 将Path类型转为路径字符串
        if file_path.endswith('.txt'):
            return self.load_txt(file_path, **kwargs)
        elif file_path.endswith('.csv'):
            return self.load_csv(file_path, **kwargs)
        elif file_path.endswith('.tsv'):
            return self.load_csv(file_path, delimiter='\t', **kwargs)
        elif file_path.endswith('.json'):
            return self.load_json(file_path, **kwargs)
        elif file_path.endswith('.yml') or file_path.endswith('.yaml'):
            return self.load_yaml(file_path, **kwargs)
        else:
            raise NotImplementedError('不支持该文件类型')
```
#### 对应Fixture方法实现
由于适用方法类往往要导入并且实例化才能使用，我们可以封装一个Fixture方法来方便用例直接使用。在根目录conftest.py中添加代码如下：
```python
from utils.data_utils import FileUtils
@pytest.fixture
def file_utils():
    """数据文件加载工具"""
    return FileUtils()
``` 
```

结合data_dir这个Fixture方法，用例中可以非常方便的加载各种类型的数据，假设data目录中存在文件data.yml，用例中加载数据方式如下：
```python
def test_use_data_file(data_dir, file_utils):
    data = file_utils.load(data_dir / 'data.yml')
    print(data)
```
### 8.3.3  数据库实用方法封装
在测试框架，特别是接口测试数据库断言中，数据库操作也是常用操作之一。除了Python自带的sqlite3模块以外，其他数据库的操作需要安装对应的三方包来进行操作，常用的数据库类型需要使用的三方包如下：
其中关系型数据库SQLite、MySQL、PostgreSQL及Oracle数据库操作方法基本一致，先建立数据库连接，使用连接对象建立“游标”（指向查询/修改数据缓冲区的一个变量），然后执行SQL即可。封装及使用逻辑，如图8.10所示。

图8.10  数据库封装及使用逻辑
#### 数据库操作封装
以MySQL为例，参考封装如下：
文件mysql_utils.py内容
```python
import logging
import pymysql
class MysqlUtils:
    def __init__(self, host, user, password, db, port=3306, charset='utf8'):
        logging.debug('连接数据库 %s' % host)
        self.conn = pymysql.connect(host=host,
                                    user=user,
                                    password=password,
                                    port=port,
                                    db=db,
                                    charset=charset,
                                    autocommit=True)
        self.cur = self.conn.cursor(pymysql.cursors.DictCursor)
        
    def query(self, sql):
        """执行查询sql并返回所有查询结果List(Dict)"""
        self.cur.execute(sql)
        result = self.cur.fetchall()
        logging.info('查询SQL：%s 结果 %s' % (sql, result))
        return result
        
    def execute(self, sql):
        """执行修改sql并返回影响行数"""
        try:
            result = self.cur.execute(sql)
        except Exception as ex:
            logging.exception(ex)
            self.conn.rollback()
        else:
            logging.debug('执行修改SQL：%s 影响行数 %s' % (sql, result))
            return result
            
    def close(self):
        logging.debug('断开数据库连接')
        self.cur.close()
        self.conn.close()
```
在以上代码中，创建MySQL对象时自动建立数据库连接和游标，在创建时使用了autocommmit参数，这样无论查询还是执行修改的SQL,每执行一次会自动commit提交。

另外，这里使用了字典类型的游标DictCursor，这样查询的每一行结果为和字段名组合后的字典类型。
这里还区分了数据库查询query和执行修改数据库的execute方法。query方法使用fetchall()返回所有查询到的数据（格式为列表嵌套字典），execute则返回影响的行数。

另外，这里并没有采用每执行一次SQL建立一连接，执行查询并关闭连接，而是保持当前连接，直到调用close()方法来关闭连接，以增加连接的复用性。
其他类型的数据库可以根据需求，在db_utils.py中添加新的类来实现封装。

假设本地数据库服务器localhost,默认端口号3306，用户名为root,密码为passw0rd,数据库demo中存在表user。查询数据方法如下：
```python
db = MysqlUtils(host='localhost', user='root', password='passw0rd', db='demo')
print(db.query('SELECT name,age,score FROM user;'))
```
运行结果如下：
```
[{'name': '张三', 'age': 16, 'score': 87}, {'name': '李四', 'age': 17, 'score': 92}, {'name': '王五', 'age': 16, 'score': 77}]
```
#### 对应Fixture方法实现
由于数据配置是分环境的，我们希望自动判断当前env配置所指定环境，并得到一个数据库操作对象，以供用例直接使用。实现方式如下，在根目录conftest.py中添加如下内容：
```python
from utils.mysql_utils import MysqlUtils
@pytest.fixture
def db(db_conf):
    return MysqlUtils(**db_conf)
```
在db这个Fixture函数中，我们可以使用request这个Pytest内置Fixture来获取命令行参数--env或pytest.ini中env的配置。如果当前指定环境db变量未配置或类型不是mysql，我们则主动抛出指定异常并说明原因。
由于命令较长，这里使用括号来处理多行字符串，括号中的多行字符串会自动拼接为一行。然后使用os.system来执行命令。
#### 根据自定义参数自动生成报告
虽然allure-pytest插件提供了参数--allure-dir来控制是否生成allure报告数据及数据目录，但每次使用--allure-dir=reports/allure-data较为麻烦，并还需要处理相对路径问题。
我们这里使用一个自定义参数gen_report来控制是否生成报告。
在初始化配置时，如果配置了gen_report参数则自动在配置中修改allure_report_dir设置（同--allure-dir参数配置）来指定生成的allure报告数据目录。
在命令行运行结束生成命令行执行概要时，如果配置的gen_report参数，则在生成allure报告数据后，使用封装的gen_report方法自动生成HTML报告。
实现方式如下，在根目录conftest.py中添加如下代码：
```python
from utils.path_utils import ALLURE_DATA_DIR
from utils.report_utils import gen_report
def pytest_configure(config):
    """Pytest初始化配置钩子函数"""
    # ...省略动态日志文件名称配置
    if config.getini('gen_report'):
        # 修改或添加--allure-dir指定的allure报告数据目录
        config.option.allure_report_dir = ALLURE_DATA_DIR
def pytest_terminal_summary(terminalreporter, exitstatus, config):
    """命令行总结钩子函数"""
    if config.getini('gen_report'):
        gen_report()  # 生成HTML报告
```
pytest.ini中`[pytest]`段中配置gen_report=True，新建一条测试用例如test_demo.py，在系统根目录命令行运行：
```
$ python3 -m pytest test_demo.py
```
可以查看运行后reports/allure-data和reports/allure-report中是否生成的报告数据及HTML报告。
> 注意：直接在PyCharm后右键运行用例不会触发pytest_terminal_summary钩子方法。
Windows用户可以使用python -m pytest test_demo.py命令来执行，相比于直接使用pytest test_demo.py，使用python作为模块调用pytest会自动将当前目录（项目根目录）添加到环境变量PYTHONPATH中去，以免导包时找不到对应模块。
### 8.3.4  发送邮件及目录压缩实用方法
运行测试完有时需要通过邮件来发送测试报告。发送邮件一般要通过SMTP协议发送。首先要在你的邮箱设置中开启SMTP服务，清楚SMTP服务器地址、端口号已经是否必须使用安全加密传输SSL等。封装及使用逻辑如图8.11所示。

8.11 邮件封装及使用逻辑

#### 发送普通邮件
使用Python发送邮件分3步：
 1. 组装邮件内容MIMEText
 2. 组装邮件头: From、To及Subject
 3. 登录SMTP服务器发送邮件

组装邮件内容MIMEText方式如下：
```python
from email.mime.text import MIMEText
import smtplib
body = 'Hi, all\n附件中是测试报告, 如有问题请指出'
body2 = '<h2>测试报告</h2><p>以下为测试报告内容<p>'
# msg = MIMEText(content, 'plain', 'utf-8')
msg = MIMEText(content2, 'html', 'utf-8')
```
使用MIMEText组装Email消息数据对象，正文支持纯文本plain和html两种格式。
组装邮件头：From、To及Subject方式如下：
```python
...
msg['From'] = 'zhichao.han@qq.com'
msg['To'] = 'superhin@126.com'
msg['Subject'] = '接口测试报告'
msg['From']中也可以声明收件人名称，格式为：
msg['From'] = '<韩志超> zhichao.han@qq.com'
msg['To']中也可以写多个收件人，写到一个字符串中使用英文逗号隔开：
msg['To'] = 'superhin@126.com,ivan-me@163.com'
```

> 注意：邮件头的From、To只是一种声明，并不一定是实际的发件人和收件人，比如From写A邮箱，实际发送时，使用B邮箱的SMTP发送，便会形成代发邮件（B代表A发送）。
登录SMTP服务器发送邮件方式如下：
```python
...
smtp = smtplib.SMTP('邮箱SMTP地址')

# smtp = smtplib.SMTP_SSL('邮箱SMTP地址')
smtp.login('发件人邮箱', '密码')
smtp.sendmail('发件人邮箱', '收件人邮箱', msg.as_string())
```

这里登录SMTP和SMTP_SSL要看邮箱服务商支持哪种，连接时也可以指定端口号，如：
```python
smtp = smtplib.SMTP_SSL('邮箱SMTP地址', 465)
```
登录时的密码根据邮箱的支持可以是授权码或登录密码（一般如QQ邮箱采用授权码，不支持使用登录密码登录SMTP）。
sendmail发送邮件时，使用的发件人邮箱和收件人邮箱是实践的发件人和收件人，可以和邮件头中的不一致。但是发件人邮箱必须和登录SMTP的邮箱一致。
sendmail每次只能给一个收件人发送邮件，当有多个收件人是，可以使用多次sendmail方法，示例如下：
```python
receivers = ['superhin@163.com', 'zhichao.han@qq.com']
for person in receivers:
   smtp.sendmail('发件人邮箱', person, msg.as_string())
```
`msg.as_string()`是将msg消息对象序列化为字符串后发送。
#### 发送带附件的邮件
由于邮件正文会过滤掉大部分的样式和JavaScript，因此直接将html报告读取出来，放到邮件正文中往往没有任何格式。这时，我们可以通过附件来发送测试报告。
邮件附件一般采用二进制流格式（application/octet-stream），正文则采用文本格式。要混合两种格式我们需要使用MIMEMultipart这种混合的MIME格式，一般步骤为：
 1. 建立一个MIMEMultipart消息对象
 2. 添加MIMEText格式的正文
 3. 添加MIMEText格式的附件（打开附件，按Base64编码转为MIMEText格式）
 4. 添加邮件头信息
 5. 发送邮件
示例代码如下：
```python
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
from email.mime.base import MIMEBase
from email import encoders
import smtplib

# 1. 建立一个MIMEMultipart消息对象
msg = MIMEMultipart()
# 2. 添加邮件正文
body = MIMEText('hi, all\n附件中是测试报告,请查收', 'plain', 'utf-8')
msg.attach(body)
# 3. 添加附件
att = MIMEBase('application', 'octet-stream')
att.add_header('Content-Disposition', 'attachment', filename=('utf-8', '', file_name))
att.set_payload(open('<附件文件路径>', 'rb').read())
encoders.encode_base64(att)
msg.attach(att)
# 4. 添加邮件头信息
...
# 5. 发送邮件
...
```
使用消息对象msg的attach方法来添加MIMEText格式的邮件正文和附件。
构造附件MIMEText对象时，要使用rb模式打开文件，使用base64格式编码，同时要声明附件的内容类型Content-Type以及显示排列Content-Dispositon，这里的attachment; filename=report.html，attachment代表附件图标，filename代表显示的文件名，这里表示图标在左，文件名在右，显示为report.html。添加邮件头信息和发送邮件同发送普通邮件一致。
#### 目录压缩方法封装
在将一个目录作为附件进行发送时，我们还需要对目录进行压缩，使用Python自带的zipfile库即可。示例封装如下：
```python
import zipfile
def zip_dir(path, output=None):
    """压缩目录默认输出文件为path末尾路径+.zip"""
    output = output or os.path.basename(path) + '.zip'  # 压缩文件的名字
    zip = zipfile.ZipFile(output, 'w', zipfile.ZIP_DEFLATED)
    for root, dirs, files in os.walk(path):
        relative_root = '' if root == path else root.replace(path, '') + os.sep  # 计算文件相对路径
        for filename in files:
            # 文件路径 压缩文件路径（相对路径）
            zip.write(os.path.join(root, filename), relative_root + filename) 
    zip.close()
    return os.path.abspath(output)
```
上例中，我们使用os.walk来遍历一个目录及所有子目录的内容，root、dirs、files分别指当前层根目录、当前所有子目录列表、当前所有文件名称列表。我们需要计算出当前文件相对压缩包根目录的路径，然后使用zip.write()将文件内容写入压缩包。
发送邮件实用方法完整内容如下：

> 代码utils/email_utils.py内容
```python
import os
import logging
import smtplib
import zipfile
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText
from email.mime.base import MIMEBase
from email import encoders

def zip_dir(path, output=None):
    """压缩目录默认输出文件为path末尾路径+.zip"""
    output = output or os.path.basename(path) + '.zip'  # 压缩文件的名字
    zip = zipfile.ZipFile(output, 'w', zipfile.ZIP_DEFLATED)
    for root, dirs, files in os.walk(path):
        relative_root = '' if root == path else root.replace(str(path), '') + os.sep  # 计算文件相对路径
        for filename in files:
            zip.write(os.path.join(root, filename), relative_root + filename)  # 文件路径 压缩文件路径（相对路径）
    zip.close()
    return os.path.abspath(output)
    
class EmailUtils:
    def __init__(self, host, user, password, port=25, enable_ssl=False):
        if enable_ssl is None:
            enable_ssl = True
        self.host = host
        self.user = user
        self.password = password
        self.port = port or DEFAULT_SMTP_PORT
        self.enable_ssl = enable_ssl
        
    def _build_msg(self, subject, receivers, body='', attachments=None):
        """组装EMAIL消息体"""
        msg = MIMEMultipart()
        msg['Subject'] = subject
        msg['From'] = self.user
        msg['To'] = ','.join(receivers)
        if isinstance(body, str) and body.strip().startswith('<'):
            # 使用html格式
            msg.attach(MIMEText(body, 'html', 'utf-8'))
        else:
            msg.attach(MIMEText(body, 'plain', 'utf-8'))
        if isinstance(attachments, list):
            for path in attachments:
                need_remove = False  # 标记是否需要移除压缩文件
                if not os.path.exists(path):
                    raise FileNotFoundError('附件文件 %s 不存在' % path)
                if os.path.isdir(path):
                    file_path = zip_dir(path)
                    need_remove = True
                else:
                    file_path = path
                # 添加附件
                file_name = os.path.basename(file_path)
                att = MIMEBase('application', 'octet-stream')
                att.add_header('Content-Disposition', 'attachment',
                               filename=('utf-8', '', file_name))
                att.set_payload(open(file_path, 'rb').read())
                encoders.encode_base64(att)
                msg.attach(att)
                if need_remove is True:  # 添加后删除压缩文件
                    os.remove(file_path)
        return msg
        
    def send_email(self, subject, receivers, body='', attachments=None):
        """组装并发送邮件"""
        logging.debug("发送邮件到 to %s" % ','.join(receivers))
        msg = self._build_msg(subject, receivers, body, attachments)
        if self.enable_ssl is True:
            smtp = smtplib.SMTP_SSL(self.host, self.port)
        else:
            smtp = smtplib.SMTP(self.host, self.port)
        try:
            smtp.login(self.user, self.password)
            smtp.sendmail(self.user, receivers, msg.as_string())
        except Exception as ex:
            logging.exception(ex)
        print("发送邮件到 %s 完成" % ','.join(receivers))
```
4.使用自定义配置项send_email控制自动发送邮件
我们使用自定义配置项send_email来控制是否发送邮件，如果配置了该参数，则我们在命令行用例执行结束生成命令行执行概要时自动发送邮件。实现方式如下，在根目录conftest.py中添加如下代码：
```python
from utils.email_utils import EmailUtils

def pytest_addoption(parser):
    parser.addoption('--send_email', action="store_true", help='auto send email or not')
    
def pytest_terminal_summary(terminalreporter, exitstatus, config):
    # ...省略生成报告配置
    # 执行完用例根据参数自动发送邮件
    if config.getini('send_email'):
        attachments = [config.option.log_file]  # 默认邮件附件中添加执行日志文件
        if config.getini('gen_report'):
            # 邮件附件中添加生成到HTML报告目录，目录自动压缩
            attachments.append(config.allure_report_dir)
        ini = config.ini  # pytest-ini插件在config中添加了pytest.ini的ConfigParser对象
        smtp_server = ini.get('smtp', 'smtp_server')
        smtp_user = ini.get('smtp', 'smtp_user')
        smtp_password = ini.get('smtp', 'smtp_password')
        smtp_port = ini.get('smtp', 'smtp_port')
        enable_ssl = ini.get('smtp', 'enable_ssl')
        subject = ini.get('email', 'email_subject')
        body = ini.get('email', 'email_body')
        receivers = ini.get('email', 'email_receivers').split(',')
        receivers = [item.strip() for item in receivers]
        EmailUtils(smtp_server, smtp_user, smtp_password, smtp_port, enable_ssl)\
            .send_email(subject, receivers, body, attachments=attachments)
```
## 8.4  接口授权及测试用例
在接口测试中，无论是基于Cookies/Session模式还是基于Token模式，我们都可以使用requests库的Session会话，通过会话保持（自动保留之前的Cookies）和默认参数来实现。Fixture及用例使用逻辑如图8.12所示。

图8.12  会话相关Fixture及用例使用方法
### 8.4.1  会话Fixture函数的实现
在8.2.4项目配置及相关Fixtures一节中，我们已经实现了token这个Fixtrue函数，我们只需要新建一个requests会话，将token放入默认的请求头中即可，在conftest.py中添加如下代码：
```python
import requests
@pytest.fixture
def session(token):
    session = requests.Session()
    session.headers['Authorization'] = 'Bearer %s' % token
    return session
```
完整conftest.py内容如下。

> 代码conftest.py内容
```python
import os
import platform
from datetime import datetime
import pytest
import requests
from utils.email_utils import EmailUtils
from utils.mysql_utils import MysqlUtils

NOW = datetime.now()

def pytest_addoption(parser):
    parser.addoption('--send_email', action="store_true", help='auto send email or not')
    
def pytest_configure(config):
    """Pytest初始化配置钩子函数"""
    root_dir = config.rootpath  # 获取项目根目录
    # 获取pytest.ini文件中的log_file配置项
    log_file = config.getini('log_file')
    if log_file:  # 如果存在该配置项2
        # 修改命令行选项中的log-file参数为日志绝对路径
        config.option.log_file = root_dir / NOW.strftime(log_file)
    # 处理allure报告路径
    alluredir = config.getoption("--alluredir")
    if alluredir is not None:
        config.option.allure_report_dir = root_dir / alluredir
        
def pytest_terminal_summary(terminalreporter, exitstatus, config):
    if config.getoption("--alluredir") is not None:
        if 'Windows' in platform.platform():
            allure = config.rootpath / 'tools/allure-2.18.1/bin/allure.bat'
        else:
            allure = config.rootpath / 'tools/allure-2.18.1/bin/allure'
        allure_data = config.option.allure_report_dir
        allure_html = config.rootpath / 'reports/allure-html'
        os.system('%s generate %s -o %s' % (allure, allure_data, allure_html))
        print('allure html报告生成成功')
    # 执行完用例根据参数自动发送邮件
    if config.getini('send_email'):
        attachments = [config.option.log_file]  # 默认邮件附件中添加执行日志文件
        if config.getini('gen_report'):
            # 邮件附件中添加生成到HTML报告目录，目录自动压缩
            attachments.append(config.allure_report_dir)
        ini = config.ini  # pytest-ini插件在config中添加了pytest.ini的ConfigParser对象
        smtp_server = ini.get('smtp', 'smtp_server')
        smtp_user = ini.get('smtp', 'smtp_user')
        smtp_password = ini.get('smtp', 'smtp_password')
        smtp_port = ini.get('smtp', 'smtp_port')
        enable_ssl = ini.get('smtp', 'enable_ssl')
        subject = ini.get('email', 'email_subject')
        body = ini.get('email', 'email_body')
        receivers = ini.get('email', 'email_receivers').split(',')
        receivers = [item.strip() for item in receivers]
        EmailUtils(smtp_server, smtp_user, smtp_password, smtp_port, enable_ssl) \
            .send_email(subject, receivers, body, attachments=attachments)
            
@pytest.fixture
def base_url(env_vars):
    """返回pytest.ini指定环境中的base_url变量，需要安装pytest-ini"""
    return env_vars.get('base_url')
    
@pytest.fixture
def token(env_vars):
    """返回pytest.ini指定环境中的token变量，需要安装pytest-ini"""
    return env_vars.get('token')
    
@pytest.fixture
def db(env_vars):  # need pip install pytest-ini
    host = env_vars.get('db_host')
    port = env_vars.get('db_port')
    user = env_vars.get('db_user')
    password = str(env_vars.get('db_password'))
    db = env_vars.get('db_name')
    return MysqlUtils(host, user, password, db, port)
    
@pytest.fixture
def session(token):
    session = requests.Session()
    session.headers['Authorization'] = 'Bearer %s' % token
    return session
```
### 8.4.2  编写接口测试用例
```python
"""测试Monica联系人接口"""
from pprint import pprint
import allure
import pytest
import pytest_check

@allure.feature("联系人管理")
class TestMonicaContactsApi:
    @pytest.mark.level(1)
    @pytest.mark.owner('hzc')
    @allure.story("获取联系人列表")
    def test_get_contact_list(self, base_url, session, db):
        url = f'{base_url}/api/contacts'
        res_dict = session.get(url).json()
        pprint(res_dict) 
        total = res_dict['meta']['total']
        db_total = db.query('select count(id) as total from contacts')[0]['total']
        pytest_check.equal(total, db_total, msg=f'接口联系人数量{total}应与数据库联系人数量{db_total}相等')
```
## 8.5  接口及业务封装
当每个接口使用频次比较高，或者请求参数构造较为复杂时，可以考虑将接口封装成函数方法来调用，即增加一层“业务层”，如图8.13所示。

图  8.13  分层接口测试框架结构示意图

一般我们按照模块或实体进行分类，每个模块或实体封装一个类，同时编写一个接口基础类来完成授权、请求封装等一些基础操作的封装，以供每个模块或实体接口类继承。
同时每个模块或实体接口类，我们使用Fixture函数来生成对象，以供用例直接拿来使用。
### 8.5.1  接口基础类封装
接口基础类主要完成基本的GET、POST等请求方法的封装（例如支持base_url）等，以及完成项目授权（登录）相关请求的封装。无论项目是使用Cookie/Session还是使用Token的方式，我们都可以使用requests库中的Session来设置和保持授权需要的Cookie和Token项。具体操作如下：
1. 新建一个请求会话request.Session()
2. 使用用户名密码请求登录接口，根据对应授权方式取出响应中的Cookie或Token。
3. 在上面的请求会话中添加默认的请求头或请求参数，根据项目授权方式，将Cookie或Token添加到其中。
4. 封装GET、POST方法都使用上面携带了Cookie或Token的会话进行发送。
这样在使用封装的GET或POST方法时，接口便自动携带了授权信息。

参考封装如下：
> 代码apis/base_api.py内容
```python
import logging
import requests

class BaseApi:
    def __init__(self, token=None, base_url=None):
        self.token = token
        self.base_url = base_url
        self.session = requests.Session()
        if token is not None:
            self.auth()
    def auth():
        self.session.headers['Authorization'] = 'Bearer %s' % token
    def request(self, method, url, *args, **kwargs):
        logging.debug(f'{method} {url}')
        if isinstance(url, str) and not url.startswith('http'):
            url = self.base_url + url
        return self.session.request(method, url, *args, **kwargs)
    def get(self, url, *args, **kwargs):
        return self.request('GET', url, *args, **kwargs)
    def post(self, url, *args, **kwargs):
        return self.request('POST', url, *args, **kwargs)
    def put(self, url, *args, **kwargs):
        return self.request('POST', url, *args, **kwargs)
    def delete(self, url, *args, **kwargs):
        return self.request('DELETE', url, *args, **kwargs)
```
在对象初始化是需要提供token及base_url参数，分别用于授权和组装完整url路径。同时也可以不传token来模拟未授权用户。如果不提供base_url则所有的接口必须写完整的接口路径，并且不能切换环境。在初始化方法中新建了一个请求会话“self.session”用于保存授权信息。
上例中还对请求会话默认的通用请求方法`self.session.request(method, url, *args, **kwargs)`进行了封装，增加了日志和base_url的处理，如果传人的url不是完整的接口地址，则拼接上服务地址base_url。其他的get、post、put、deleted等请求方法基于request方法来实现。这样封装的好处所有的请求都需要经过封装的request方法，方便对请求进行统一控制，例如增加日志输出、对常见请求异常进行处理或基础断言等。
auth方法用于完成授权，如果传人了token，在生成对象时将自动完成授权。对于需要使用用户名、密码获取token或登录的场景，可以将初始化方法设计为传人user及password。对于使用Cookie / Session授权机制的，只需要使用self.session请求登录接口即可（会自动保留响应返回的Cookies），示例如下：
```python
class BaseApi:
   def __init__(self, user=None, password=None, base_url=None):
        self.user = user
        self.password = password
        self.base_url = base_url
        self.session = requests.Session()
        if user is not None and password is not None:
            self.auth()
    def auth():
        # 基于Cookie/Session鉴权机制
        login_url = '/api/login'
        data = {'username': self.user, 'password': self.password, 'act': 'signin'}
        self.post(login_url, data=data)
如果是基于Token的授权机制，还需要从响应中提取出相应的token，并添加到会话相应位置（请求头某个字段或URT参数中，根据项目鉴权要求而定），示例如下。
    def auth():
        # 基于Token鉴权机制
        login_url = '/api/login'
        data = {'username': self.user, 'password': self.password}
        res_dict = self.post(login_url, json=data).json()
        token = res_dict['data']['adminToken']
        self.session.headers['Admin-Token'] = token
```
### 8.5.2  业务模块接口封装
在完成接口基础类封装后便可以基于其封装各个业务模块的接口类，以Monica项目的联系人（contacts）模块为例，封装示例如下：

> 代码apis/contact_api.py内容
```python
from apis.base_api import BaseApi
class ContactsApi(BaseApi):
    def list_contracts(self, limit: int=None, page: int=None, query: str=None, sort: str):
        """联系人列表接口"""
        url = '/api/contacts'
        params=dict(limit=limit, page=page, query=query, sort=sort)
        res = self.get(url, params=params)
        return res.json()```
在业务接口中，我们可以将常用需要修改的接口参数暴露为方法参数（其他固定或基本不会变的参数可以直接写死或为对应参数提供默认值）。业务接口的url应只写其接口路径，以方便切换环境。这里接口请求后直接返回了JSON转为字典格式的请求数据，方便用户直接使用。
同时为方便用例使用，我们还需要封装对应的Fixture方法，在conftest.py中添加代码如下：
```python
from apis.contact_api import ContactsApi
@pytest.fixture
def contacts_api(token, base_url):
    return ContactsApi(token, base_url)
```
该Fixture函数只是将对应的接口类实例化生成对象，好处是用例需要使用联系人接口时，可以直接使用，而无须导入ContactApi并进行实例化操作，示例用例如下。
```python
@allure.feature("联系人管理")
class TestMonicaContactsApi:
    def test_get_contact_list_02(self, contacts_api, check):
        res_dict = contacts_api.list_contracts()
        print(res_dict)
        # ....
```
### 8.5.3  使用接口聚合类
虽然Fixture函数可以让用例拿来即用，直接调用封装的方法来请求接口，但当业务接口类比较多时，就会产生很多个Fixture函数，用户使用时往往需要翻阅conftest.py文件或命令行使用“pytest --fixtures”来查看有哪些可用的接口对象Fixture方法。此时，为用户提供一个统一的使用入口是比较好的一种方式，我们可以增加一个接口聚合类，来将所有的接口对象集成起来，并提供Fixture函数来方便用户直接使用，如图8.14所示。

图8.14  增加接口聚合类的接口分层模型

接口聚合类封装示例如下：
> 代码apis/api.py内容
```python
from apis.base_api import BaseApi
from apis.contacts_api import ContactsApi
class Api(BaseApi):
    def __init__(self, token, base_url=None):
        super().__init__(token, base_url)
        self.contacts = ContactsApi(token, base_url)
        # ... 其他业务接口类对象
对应Fixture方法，在conftest.py中添加代码如下：
from apis.api import Api
@pytest.fixture
def api(token, base_url):
    return Api(token, base_url)
用例使用方法如下：
@allure.feature("联系人管理")
class TestMonicaContactsApi:
    def test_get_contact_list_03(self, api, check):
        res_dict = api.contacts.list_contracts()
        print(res_dict)
```
### 8.5.4  数据库操作封装
同样作为业务层，我们可以对常用的数据操作进行封装，示例如下：
> 代码services/monica_db.py内容
```python
from utils.mysql_utils import MysqlUtils

class MonicaDb(MysqlUtils):
    def count_contacts(self):
        return self.query('select count(id) as total from contacts')[0]['total']
如果数据库操作很多，也可以分多个类进行封装，提供多个Fixture函数或一个聚合Fixture函数。
对应Fixture函数，在conftest.py中添加如下代码：
from sevices.monica_db import MonicaDb
@pytest.fixture
def monica_db(db_conf):
    return MonicaDb(**db_conf)
```
用例使用方法，如下：
```python
@allure.feature("联系人管理")
class TestMonicaContactsApi:
    def test_get_contact_list_04(self, api, monica_db, check):
        res_dict = api.contacts.list_contracts()
        total = res_dict['meta']['total']
        db_total = monica_db.count_contacts()
        check.equal(total, db_total, msg=f'接口联系人数量{total}应与数据库联系人数量{db_total}相等')
```

> 注意：在实际场景中，有可能只有部分环境的数据库权限（如无prod生产环境的权限），则需要添加环境判断，或统一不使用数据库断言，改为使用其他接口辅助断言。

完整测试框架可参考：<https://github.com/hanzhichao/MonicaApiAutoTest>。
## 8.6  小结
本章通过Monica这个开源项目，这里演示了基于Pytest接口测试框架的常见插件的使用，常用的测试配置及测试流程定制方法，数据库、数据文件读取、发送邮件等使用方法的封装及使用，接口业务操作封装及数据库业务操作封装以及使用接口聚合类来统一各个api的调用等。框架中大量的使用了Pytest的Fixture方法，用各种Fixture来方便用例无需导入，拿来即用，以方便用例的编写。
