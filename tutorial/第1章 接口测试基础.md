随着前后端分离、分布式系统及微服务的流行，接口测试越来越受到重视。接口是UI功能的基础，各模块、微服务通过接口进行数据交互。接口测试相较于UI测试较为底层，在做接口测试之前，我们需要了解和掌握一些网络基础知识，HTTP协议等。
本章主要内容如下：

- 接口概念、处理流程及分类；
- 掌握接口测试的意义、测试流程及测试要点；
- 掌握HTTP协议请求方法、常见请求头及常见状态码；
- 掌握Fiddler抓包方法；
- 掌握cUrl命令、Postman及JMeter的基本使用。

## 1.1  接口及接口测试

本节主要讲解什么是接口、处理流程、分类，以及接口测试的意义、接口测测试的一般流程接口测试要的要点等。

### 1.1.1  接口的概念

接口，即使用功能接入口。接口有多种概念，包含硬件接口、软件接口等，本书所指接口主要指软件接口，即API（Application Programming
Interface）应用程序接口。
应用程序接口（API），是为外部提供服务的一组程序，在单元函数的基础上提供了外部访问方式。接口为上层用户界面提供数据或服务，如图1.1所示。

图1.1 登录界面及后台接口

应用程序常常分为前端（网页、App等）和后端（服务端程序），我们在界面上（前端）的很多操作往往是通过后端的接口进行处理和实现的。如上图1.1，“SIGN
IN”按钮，点击后会调用后台的登录接口。页面资源也是一种接口，“Forgot Password”和“SIGN UP”则通过分别调用后台的重置密码页面及注册页面接口。
从本质上来说，接口也是一段代码，一个函数或者类，在内部调用其他函数和类的功能实现业务操作。不同于一般单元函数的是，接口提供了可供外部访问途径并暴露为一种服务，即其他远程模块，系统或人员可以通过接口提供的地址来使用接口提供的功能。
因此，接口是各个模块或子系统的提供了数据交互的功能，同时接口也是UI界面功能的基础。UI界面收集用户的意图，并通过调用接口完成响应的业务操作。
一般来说，接口有以下特点。

1. 接口提供服务，是上层UI界面操作的基础；
2. 接口提供外部访问途径；
3. 访问接口必须使用指定的参数和规定的格式；
4. 接口一般都具有一定的鉴权（身份验证）机制。

### 1.1.2  接口的处理流程

当我们在浏览器中输入一个网址后，一次完整的网络请求会经历哪些过程呢？在接口中又是如何处理请求的呢？
1.一次完整的网络请求的过程
浏览器中的一次网络请求往往要经历，构造请求，查询缓存、域名解析、建立连接、网关转发（反向代理）、服务端处理、重定向、浏览器解析的过程，如图1.2所示。
图 1.2 浏览器一次完整的网络请求的流程

1. 构造请求：当用户在浏览器输入网址并按回车后，浏览器会尝试补全URL（比如前面补充https:
   //），查询当前域名下是否有相应的Cookies标记，然后构造出完整的基于HTTP协议的GET请求以准备发送。
2. 查询缓存：在发送请求钱会首先查询内存缓存及磁盘缓存是否已经有对应的资源，以及是否过期，如果有且没有过期，则直接从缓存中读取并返回浏览器处理。如果没有查询到（未命中查询）或者缓存已失效，则进入下一个环节。
3. 域名解析：也称Name Lookup或DNS Lookup。及通过域名如“www.baidu.com
   ”找到对应的IP地址的过程。浏览器一般会缓存一些我们常用的域名对应的IP地址，如果查询不到则查询本地HOSTS中是否有该域名对应的IP配置，如果没有则访问当前网络配置的DNS服务器以获得对应的IP地址。并根据用户输入或协议得到默认的端口号（如HTTPS默认端口未443）。
4. 建立连接：当解析出目标域名的IP地址及端口后，浏览器则会尝试跟服务器建立TCP连接（即三次握手）。如果是HTTPS协议，在建立连接后还需要进行SSL/TLS握手（即密钥协商），以保证通信安全。
5. 网关转发（反向代理）：一般情况下在应用服务器外会有网关服务器作为前哨，也叫反向代理（如Nginx），反向代理起到负载均衡及转发请求的功能。
6.
服务端处理：服务端收到网关转发的请求后，经过接口服务的应用程序的路由表找到对应的接口，接口一般会对用户身份进行校验，解析请求并提取参数，进行业务处理并组装基于的HTTP协议的响应。服务端返回响应后会根据原请求头中的Connection选项是Keep-Alive还是close来决定是保持TCP连接还是断开连接（即4次挥手）。
7. 如果对应的接口需要重定向到另一个接口处理，则会返回状态码301或302，浏览器需要向重定向的接口重新请求数据。
8. 浏览器获得响应后，会对返回的HTML进行解析，并批量请求网页中依赖的其他资源（如图片、样式、脚本等），并且这些连带请求的资源的请求头中的Refferer项会指向当前请求（及这些请求由当前请求引出）。
   2.接口的处理流程
   单从接口处理请求来说，接口的处理流程一般分为请求、处理、响应三个部分，如图1.2所示。当接口编写及部署好后，便已经确定了其服务器地址、接口地址、需要的参数及使用的固定格式及各种情况的响应结果。
   图1.3 接口的流程
   如图1.2所示，我们要使用接口提供的服务，需要按照接口的地址、参数及固定格式等要求（一般写作接口文档中），组装报文并发送给接口所在服务器，接口处理完业务后组装成响应报文发送给我们。

### 1.1.3  接口的分类

严格来说，接口并没有具体的分类，不过我们可以根据使用的协议及架构把接口简单分为HTTP接口及RPC接口两种类型（两种类型也存在一定的交叉）。
#### 1．HTTP接口
HTTP接口即使用HTTP及HTTPS协议传输数据或资源的接口。
由于HTTP协议的广泛使用，HTTP接口简单灵活，兼容性强。几乎所有类型的平台（Windows、Linux、MacOS、Android、iOS等）以及几乎所有编程语言（C、C++、C#、PHP、Java、Golang、Python等）都支持HTTP协议。
HTTP接口唯一缺点是性能略弱，因此一般用于外部（用户）接口，而内部模块之间的接口则一般会用RPC接口来获得更好的性能。

1. RESTful API
   在HTTP接口的设计上，不同的程序员有不同的风格。其中RESTful （表征性状态转移）API是一种较为流行的HTTP接口的设计风格或规范，其主要特点如下：
1. 将接口视为一种资源，一般使用名词作为接口端点（接口路径的最后一级名称）；
2. 接口路径统一管理，并分版本，如接口路径都放在“/api/v1/”之下；
3. 同一个接口路径使用不同的请求方法实现不同的操作，如使用POST方法新建、GET方法获取列表或详情、PUT方法修改、DELETE方法删除资源；
4. 请求和响应统一使用JSON格式；
   普通HTTP接口于RESTful风格接口的简单对比，如表1.1所示。
   表1.1 普通HTTP接口于RESTful风格接口对比

| 接口功能   | 普通HTTP接口                       | RESTful API            |
|--------|--------------------------------|------------------------|
| 新建用户   | POST /user/create_user         | POST /api/v1/users     |
| 查询用户列表 | GET /user/get_user_list        | GET /api/v1/users      |
| 查询用户详情 | GET /user/get_user_detail?id=1 | GET /api/v1/users/1    |
| 更新用户详情 | POST /user/update_user         | PUT /api/v1/users/1    |
| 删除用户   | POST /user/delete_user         | DELETE /api/v1/users/1 |

#### 2．RPC接口

RPC（Remote Procedure Call），即远程过程（函数或方法）调用。
随着应用程序的复杂化，不同的模块和功能可能部署在不同的服务器上。同时，不同的模块也可能使用不同的编程语言实现。RPC的目的是直接调用远程服务器的某段程序并直接获得结果。
RPC主要解决跨服务器及跨语言调用问题，同时提高内部模块之间远程交互的性能。
在内部模块远程交互时，如果直接使用HTTP请求，每次进行组装请求、校验解析请求流程，流程往往较为复杂且没有必要。加上HTTP协议本身的一些问题（如即请求数据很少时也需要一大堆请求头），性能往往偏弱。
RPC本质上是一种问题方案或解决该问题的框架。如果不太追求性能也可以基于HTTP协议，如Web Service、JSON RPC、XML
RPC等。也可以直接基于TCP协议以实现更好的性能，如Dubbo、gPPC及Thrift等。
RPC框架需要解决的基本问题如下：

1. 如何找到对应的服务（远程模块）；
2. 如何描述所需调用的函数、参数及参数格式（如果跨语言则还需要处理数据类型的映射）并转换为二进制数据；
3. 采用何种协议传输数据；
4. 服务端如何将收到的二进制数据还原成调用请求，并将任意类型的结果（数字、字符串或对象）安约定格式转换成二进制；
5. 客户端如何将收到的二进制结果还原得到调用的原始结果；
6. 更复杂的RPC框架一般还需要有鉴权、负载均衡等功能；
   这就需要客户端及服务端都有对应的转换桩（Stub）来按照指定协议完成调用请求及结果与二进制数据的相互转换，如图1.4所示。

图 1.4 RPC框架常见架构结构
如图1.4所示，RPC框架的一次远程过程调用基本流程如下：

1. 服务端启动RPC服务时向服务中心（如Zookeeper）注册服务。
2. 客户端使用RPC框架提供的方法调用指定服务的某个函数；
3. 客户端通过RPC框架的转换桩Stub按指定协议将调用请求序列化成二进制数据；
4. 客户端从服务中心查询到指定服务的IP地址及端口号；
5. 客户端将序列化的调用请求数据按照TCP或HTTP协议发送到服务端；
6. 服务端转换桩（Skeleton）将调用请求还原；
7. 服务端处理调用请求并得到调用结果；
8. 服务端将调用结果通过转换桩（Skeleton）将调用结果序列化成二进制数据；
9. 服务端通过TCP或HTTP协议将序列化的调用结果发送给客户端；
10. 客户端转换桩（Stub）将序列化的调用结果还原得到真实的调用结果。

> 注意：服务中心并不是不是必须的，当服务很多时，服务中心用于统一注册和查询服务，如果直接知道服务地址及端口，客户端可以直接连接服务。

### 1.1.4 接口测试的意义

测试工作的本质在于尽早的发现问题，从而降低修复成本，因此，测试人员应尽早的介入的软件流程中来。接口测试介于单元测试与系统测试之间，单元测试一般由开发完成，开展接口测试可以及早发现问题，有效降低测试成本。
接口是各种系统功能的基础，一旦接口出现问题可能会引起许多系统功能的问题并且不容易定位。同时，接口一般较UI相对稳定，利于进行自动化、服务监控和持续集成。另外，分层进行多轮测试可以过滤出更多问题。因此，在系统测试前进行接口测试是非常有价值的。
开展接口测试的优点如下：

1. 尽早发现服务端问题，降低修复成本；
2. 增加接口测试可以更多的过滤问题；
3. 服务端出现问题一般较为严重，系统的接口测试可以有效避免上线后的重大问题；
4. 提前过滤绝大多数服务端问题，有效减轻系统测试（客户端测试）的工作量及压缩整体测试排期；
5. 相比于客户端测试，接口测试可以突破客户端现在覆盖到并发、大数据量、参数缺失等更多异常场景，使测试更充分。
   同时开展接口测试也有一些弊端：
1. 接口测试不能替代最终的系统测试（客户端测试）；
2. 接口测试需要投入更多的资源，服务端测试人员具有更高的要求（如需要了解协议、服务端架构、中间件、数据库、Linux命令甚至需要Review各种语言的代码）；
3. 接口测试可能会干扰前后端连调进度及系统提测时间；
4. 怎见额外的接口流程没有衔接好可能会增加整体的测试时间；
   注意：接口测试一般指手工接口测试。接口自动化不同于接口测试。接口自动化的目的在于快速回归后端接口以及线上巡检，避免接口变动影响原有功能或线上接口异常及时预警。

### 1.1.5  接口测试的流程

接口测试一般由服务端测试人员负责，或由功能测试人员兼做接口测试。

#### 1.接口测试的流程

接口测试的一般流程为：

1. 服务端测试人员根据接口文档和PR文档编写接口测试用例；
2. 服务端提测后，测试接口功能；
3. 接口功能测试完成后根据需要测试某些接口性能；
4. 测试完成进入系统测试阶段后，进行接口自动化用例的开发。
   完整流程如图1.5所示。
   图1.5 接口测试流程
   如上图，由于前端开发依赖后端开发的数据，为保证并行开发，后端开发和前端开发会约定好数据格式（称为契约），前端使用Mock
   Server工具构造相应格式的假数据进行开发。
   编写接口测试用例重要依据严重依赖接口文档，另外还应结合PR文档审视，接口功能是否覆盖了所有需求场景。接口自动化用例，除用作线上监控外，还用做之后的接口回归或冒烟测试。

#### 2.接口测试的准入时机

接口测试一般在服务端提测后进行。如果没有服务队提测动作，接口测试一般在前后端连调左右执行。在前后端联调前进行则需要先暂停连调，一般问题会较多，接口测试会不太顺利，并影响进度，但对利后续的前后端连调比较有利。如果在联调时进行，接口则会不断变动，后端开发需要同时应付前端和服务端测试的问题。如果在联调后进行，则已经修复了大部分问题，接口较为稳定，比较利于接口测试的开展，但联调通过其实已经可以客户端提测进入系统测试阶段，因此接口测试不适合拖太久。

#### 3.接口测试的准出原则

接口测试一般要求一定的覆盖率，如条件覆盖率100%。但是接口测试一般无法向单元测试一样直接得到测试覆盖率（一般需要落地对应精准测试方案，或个人评估）。
在接口测试所有用例执行完成、性能测试及后端问题修复完成后，便可出具接口测试报告，完成接口测试。

#### 4.接口测试的衡量标准

一般以服务端问题的漏测率来衡量接口测试的质量。接口测试阶段应过滤到绝大多数服务端问题，在系统测试阶段发现的服务端问题视为接口测试的漏测。

### 1.5.3  接口文档

接口文档是前后端的一种契约，是前端开发、接口测试用例及接口自动化用例的重要依赖。因此接口文档的变更应及时通知到相关人员。接口文档一般写在Wiki中，使用Word、Excel不便于变动的同步更新和版本管理。
接口文档一般应提供清晰的接口路径、请求方法、数据格式、参数、参数类型、对应的业务操作已经示例响应等等，以下为一个示例接口的文档。
严格来说，接口文档还应指出使用的鉴权方式。然而由于一个项目所有接口都一般采用同一种鉴权方式，因此一般接口文档中并不注明，调试接口时需要向开发进行了解响应及鉴权方式。
对于某个接口的接口文档，我们需要从中获取以下信息：

1. 接口的功能及使用场景；
2. 接口路径、及当前服务部署地址；
3. 接口鉴权机制（重要）；
4. 请求方法（GET还是POST）
5. 数据格式（URL参数、JSON还是表单）；
6. 每个接口参数的意义，是否必须及如何构造或获取（难点）；

### 1.5.4  接口测试要点

接口用例分为单测用例和场景用例两种。单测用例从单个接口的功能和参数出发，每个参数都是一个交互点，结合业务，通过不同的参数组合来编写用例。场景用例以用户实际场景，通过多个接口的连续调用来模拟业务流程。一般来说，由于接口的主要使用对象为前端或其他模块的开发人员，接口测试应以正常用例及业务场景为主。
接口用例设计应确保对变动代码达到一定的覆盖率（比如分支覆盖率100%），对于专职的服务端测试人员来说，接口测试是介于，白盒和黑盒之间的灰盒测试。在服务端提测后，通过Git
Changes和Review代码来明确代码的业务逻辑，对应代码逻辑设计响应的用例以达到指定覆盖率。
对应服务端提测前或纯黑盒的接口用例来说，可以参考以下几点。

1. 首先应核对接口功能是否覆盖了需求中所有的功能点和场景。
2. 由于请求接口必须使用指定的参数和规定的格式，接口文档是接口测试的必要条件，如果没有，需要跟响应的开发沟通了解接口请求方式，参数，格式，鉴权方式等必要信息。
3. 接口测试用例应至少覆盖所有的响应结果。
4. 注意接口的字段，返回值类型是否与前端约定的一致。
5. 注意边界值及负数的验证。
6. 注意接口重复请求、并发请求及数据量较多的请求。
7. 注意用户场景（多接口联动）的验证。

## 1.2  网络基础知识

接口一般分布在不同的远程服务器上，请求及响应信息要通过网络进行传输。因此在学习接口之前我们需要了解并掌握一些网络基础知识，如OSI参考模型、TCP五层模型、TCP及UDP协议、IP、端口、域名、DNS等。

### 1.2.1 网络模型

网络模型是网络通信的一种架构模型及规范标准。常见的网络模型有OSI考模型和TCP/IP五层或四层模型。

#### 1．OSI参考模型

OSI(Open System Interconnect)，开放式系统互联，一般称为OSI参考模型，是由国际标准化组织在1985年提出的一种网络互连的参考模型。
OSI参考模型将网络分为七层，由下至上分别为物理层、数据链路层、网络层、传输层、会话层、表示层和应用层，如图1.6所示。
图1.6 OSI参考模型
这七层根据软件、硬件的不同又可分为上3层和下4层，上三层为应用层，负责控制软件方面的数据交互，下4层为数据流层，负责硬件方面的数据通信。

#### 2．TCP/IP 5层模型

由于OSI协议繁琐，开销较大，实际在互联网上使用另一种更简洁、使用的TCP/IP网络模型。TCP/IP将网络分为五层或四层，五层协议从上到下分别为应用层、传输层、网络层、数据链路层和物理层，四层模型中网络层和数据链路层统称为网络层。TCP/IP五层网络模型与OSI对应关系，如下图1.7所示：
图1.7 TCP/IP参考模型
在TCP/IP五层网络模型中应用层对应OSI参考模型的上三层，负责软件层面的数据交互。下四层和OSI参考模型的下四层一一对应，负责硬件层面的数据传输。

### 1.2.2  TCP及UDP协议

当数据通过网络层IP协议确定了要通信的主机时，我们就要通过网络层开始传输数据，此时有两种策略，一种类似于生活中的发短信，是只管发，不管对方收到了没有。另一种，类似生活中的打电话，是先跟对方建立好连接，然后发送并确认对方收到了完整的信息。这两种策略对应传输层的两种主要协议UDP协议及TCP协议。UDP协议及TCP协议报头对比，如图1.8所示。
图1.8 TCP报文格式
上图可见UDP协议报头格式比较简单，控制字段较少，TCP协议头部控制字段较多，开销较大。

#### 1．TCP协议

TCP（Transmission Control Protocol），即传输控制协议，是一种面向连接的可靠的数据通信协议。
TCP协议的主要特点：

1. TCP是面向连接的。
2. 每条TCP连接只能用于两个短点，一对一。
3. TCP提供可靠交付的服务：连接传输数据、无差错、不丢失、不重复、并且按序到达。
4. TCP提供全双工通信。
5. 面向字节流。TCP根据对方给出的窗口和当前网络拥塞的程度来决定一个报文应该包含多少个字节。

#### 2．UDP协议

UDP（User Datagram Protocol），即数据报文协议，一种无须建立连接，尽力交付数据的协议。
UDP协议的主要特点：

1. 无链接。
2. UDP使用尽最大努力交付，不保证可靠性。
3. UDP是面向报文的，UDP对应用层交付下来的报文，既不合并，也不拆分，而是保留这些报文的边界。应用层交给UDP多长的报文，UDP就照样发送，即一次发送一个报文。
4. UDP没有拥塞控制。
5. UDP支持一对一、一对多、多对一和多对多的交互通信。
6. UDP的首部开销小，只有8字节。

### 1.2.3  IP地址

客户端要和服务端通信，首先要知道服务端的IP或域名，然后通过指定端口与服务进行通信。
IP是用来唯一标识一台联网设备的逻辑地址，采用统一的格式。设备之间通过IP地址进行相互查找和通信。
目前常见的有IPv4和IPv6两个版本，IPv4协议中，IP地址由4段0~255的数字组成。如192.168.1.1。
Windows系统查看本机IP命令如下：

```bat
ipconfig
```

Linux或Mac OS系统查看本地IP命令如下：

```bash
$ ifconfig
eth0: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
     inet 10.1.204.101  netmask 255.255.252.0  broadcast 10.0.255.255
     inet6 fe80::438:d2ff:fe00:247  prefixlen 64  scopeid 0x20<link>
     ether 06:38:d2:00:02:47  txqueuelen 1000  (Ethernet)
     RX packets 829741657  bytes 385489130359 (359.0 GiB)
     RX errors 0  dropped 67532  overruns 0  frame 0
     TX packets 845676868  bytes 301067570418 (280.3 GiB)
     TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0
......
```

设备可能会有多块网卡，eth0为其中某一块网卡，inet后的10.1.204.101及位当前设备的一个IP地址。

### 1.2.4  端口

为满足网络设备提供不同服务的能力，设备通过“端口”与外部通信，一个设备（一个IP地址）一般可提供65535个端口。IP+端口，提供了一组完整的通信地址，在接口中称为base
url。
端口（Port）为设备与外界通信的出入口。端口分为：公认端口：0-1023，用于标准协议，注册端口：1024-49151，用于软件固定注册某个服务，如MySQL(
3306)，Tomcat(8080)等，动态端口：49152-65535：用于软件临时绑定一些服务。
Windows系统查看端口命令如下。

```bat
netstat -ano
```

Linux系统查看端口命令如下：

```bash
$ netstat -ntlp
(Not all processes could be identified, non-owned process info
 will not be shown, you would have to be root to see it all.)
Active Internet connections (only servers)
Proto Recv-Q Send-Q Local Address          Foreign Address        State       PID/Program name   
tcp        0      0 127.0.0.1:8601          0.0.0.0:*               LISTEN      -                  
tcp        0      0 127.0.0.1:50905         0.0.0.0:*               LISTEN      -                  
tcp        0      0 127.0.0.1:3450          0.0.0.0:*               LISTEN      -
......
```

其中Proto为协议，Secv-Q和Send-Q分别是网络接收和网络发送队列，Local Address为本机地址和端口号，Foreign
Address为外部访问的地址和端口号，State为连接状态，PID/Program name为使用该端口的进程或应用程序名称。

### 1.2.5  域名

由于IP地址不容易记忆，为IP地址赋予了一个利于记忆的别名，称为域名。
如，百度的IP为：61.135.169.125，对应的域名为 www.baidu.com。
Windows、Linux或Mac OS查看域名所对应的IP地址的命令为ping。
如ping www.baidu.com可看到返回www.baidu.com所对应的IP地址。

```bash
$ ping www.baidu.com
PING www.a.shifen.com (61.135.169.125) 56(84) bytes of data.
64 bytes from 61.135.169.125 (61.135.169.125): icmp_seq=1 ttl=53 time=1.63 ms
64 bytes from 61.135.169.125 (61.135.169.125): icmp_seq=2 ttl=53 time=1.35 ms
64 bytes from 61.135.169.125 (61.135.169.125): icmp_seq=3 ttl=53 time=1.42 ms
......
```

其中，from后面的IP地址61.135.169.125即域名www.baidu.com的IP地址。64
bytes是每次发送的数据量，icmp_seq是ping发包的序列，ttl是请求包的生存时间周期，time为ping的响应时间。

### 1.2.6  DNS

为了确保域名的唯一性，我们需要一个权威的机构来管理域名和IP地址的对应关系。于是出现了DNS。
DNS（Domain Name System）即域名解析系统，提供了域名到IP的解析服务。
除了权威的DNS域名解析系统之外，PC设备中一般还提供一套自身的域名解析配置，称为HOSTS。
本地hosts的优先级大于DNS，也就是说如果你本地hosts中配置了某个IP指向www.baidu.com，当你访问www.baidu.com时。
本地HOSTS配置方法如下：
HOSTS是设备本地的IP和域名的路由表文件，不同系统平台的文件位置如下：

- Windows系统：C:\Windows\System32\drivers\etc\hosts
- Linux或Mac OS系统：/etc/hosts
  HOSTS文件中，每一行为一条路由设置，格式为：IP 域名，示例如下：

```
127.0.0.1   localhost
```

> 注：一般Nginx反向代理接口都需要配置HOSTS，然后通过域名访问接口。

在接口测试中，如果我们需要频繁切换HOSTS来测试不同的环境，可以使用软件Switch Hosts，支持Windows/Linux/Max OS。

## 1.3  HTTP协议

HTTP（Hyper Text Transfer Protocol），即超文本传输协议，一种基于TCP协议的应用层协议，结构简单。HTTP最初是用于从WWW服务器传输网页、图像等数据到本地浏览器进行浏览，由于其格式简单，使用方便，现在也广泛应用于传输JSON及XML等格式的接口数据。
HTTP协议包含请求（Request）和响应（Response）两部分组成，请求由请求行、请求头及请求数据三部分组成。响应由状态行、响应头及响应数据三部分组成。
HTTP协议是一种无状态协议，在HTTP协议中只提供了本次交互的请求及响应的格式规范，默认并不记录之前请求的状态。

### 1.3.1  HTTP版本

HTTP协议经历了HTTP 0.9，HTTP 1.0，HTTP 1.1及HTTP 2.0几个版本，HTTPS是是HTTP + SSL 或TLS，即安全的HTTP协议。
#### 1．HTTP 0.9
HTTP0.9为最初的草稿版本，仅支持从服务端返回网页源码。
####2．HTTP 1.0
HTTP1.0形成了比较完整的HTTP协议，支持GET，POST和HEAD方法，支持Cache缓存控制，支持不同的数据内容类型Content-Type，同时补充了响应的状态码。
####3．HTTP 1.1
HTTP1.1在HTTP 1.0的基础上又补充了OPTIONS、PUT、PATCH、DELETE、TRACE、CONNECT 6种请求方法。增加了长连(Keepalive)
的支持，加入了管道机制，支持断点续传，并补充了24个错误状态码。HTTP 1.1协议是目前使用的主流协议版本。
####4．HTTP 2.0
相较于HTTP 1.0及1.1，HTTP2.0协议改变较大，HTTP2.0不再使用文本格式而统一使用新的二进制格式封装数据，称为"帧"
，同时HTTP2.0支持多路复用，Header压缩以及服务端推送，极大的优化了HTTP协议的性能。

### 1.3.2  HTTPS

HTTP协议传输的数据都是未加密的，HTTPS协议是由HTTP+SSL协议构建的可进行加密传输、身份认证的网络协议，要比HTTP协议安全。
HTTPS和HTTP的区别如下：

1. HTTPS协议需要到CA申请证书，一般免费证书较少，因而需要一定费用。
2. HTTP是超文本传输协议，信息是明文传输，HTTPS则是具有安全性的SSL加密传输协议。
3. HTTP和HTTPS使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。
4. HTTP的连接很简单，是无状态的；HTTPS协议是由HTTP+SSL协议构建的可进行加密传输、身份认证的网络协议，比HTTP协议安全。

> 注：在接口测试中HTTPS协议的接口和HTTP协议的接口请求方法一致。HTTPS协议对接口的性能有部分损耗。

### 1.3.3  HTTP请求

请求是客户端发送给接口的请求对象，在HTTP协议中请求分为请求行，请求头和请求数据三部分，请求HTTP原始数据如下所示：
GET请求：

```
GET https://httpbin.org/get?name=Kevin&age=12 HTTP/1.1
Accept: */*
Cache-Control: no-cache
Host: httpbin.org
Accept-Encoding: gzip, deflate, br
Connection: keep-alive


```

POST请求： #TODO 补充

```
POST https://httpbin.org/post HTTP/1.1
Accept: */*
Cache-Control: no-cache
Host: httpbin.org
Accept-Encoding: gzip, deflate, br
Connection: keep-alive
Content-Type: application/x-www-form-urlencoded
Content-Length: 17


```

请求报文可以分为三部分：

1. 请求行：第一行，包含请求方法，接口地址 HTTP协议版本。
2. 请求头（Headers）：第2-N行（空行之前），包含各种请求及连接的辅助信息。
3. 请求数据：长度不限，可以为空。使用固定格式是一般要在请求头中声明所使用的内容类型（Content-Type）。

#### 1．请求方法（Request Method）
   请求方法指该请求的动作或意图，常见的请求方法有GET、POST、PUT、DELETE等，如表1.1所示：
   表1.1 HTTP 1.1请求方法说明

| 请求方法    | 说明                      |
|---------|-------------------------|
| GET     | 获取相关请求资源                |
| POST    | 向指定位置创建资源               |
| HEAD    | 类似于GET请求，只获取响应头，不获取响应数据 |
| OPTIONS | 允许客户端查看接口允许的请求方法        |
| PUT     | 对已知资源进行更新               |
| PATCH   | 用来对已知资源进行局部更新           |
| DELETE  | 请求删除指定资源                |
| TRACE   | 回显服务器收到的请求，用于定位问题       |
| CONNECT | 预留给能够将连接改为管道方式的代理服务器    |

不同的请求方法本质上是一样的，都可以有URL，请求参数，请求头，请求数据等。然而一般来说，使用GET、HEAD、DELTE等方法时不发送请求数据，参数通过URL中的请求参数传递。
由于GET请求可以直接通过浏览器地址栏访问，因此GET请求可以被记录，收藏及缓存，请求参数直接暴露在地址栏中，同时由于URL长度的限制，GET请求当大量的参数时，会有截断风险。
在标准的使用模式下，POST每次都会在指定位置产生新的资源，这可能对后面的创建请求产生影响，因此，POST请求是唯一一个非幂等的请求方法。

>注：请求方法幂等性是指，本次请求对后续请求的影响。如使用POST请求创建name为张三的用户，假如name唯一，再次创建name为张三的用户时就会报错。而PUT请求一般是先查找到该用户再修改。DELETE请求，如果找到该用户则删除，找不到则不删除，因此PUT和DELETE请求是幂等的。

#### 2．请求地址（Request URL）
URL（Uniform Resource Locator），即统一资源定位符，网络上每一个接口都被视为一种资源，URL标识了该资源（接口）的地址。
URL一般由协议（Schema）、服务器地址（Host）、端口号（Port）、接口地址（Path)、及查询参数（Query）组成，例如：

```
https://httpbin.org:443/get?a=1&b=2
https://www.baidu.com/
```

其中“https”为协议名，“httpbin.org”为服务器地址，端口号省略（采用HTTPS协议默认的端口443），接口地址为“/get”，“a=1&b=2”为查询参数，以“&”分割。
某些情况下（如采用Basic Auth授权的接口），URL地址中也可以包含用户名及密码信息，格式为：

```
<scheme>://user:password@<host>:<port>/<path>?<query[[hzc1]](#_msocom_1) >
```

#### 3．请求头（Request Headers）
请求头是请求及连接的辅助信息。常见请求及释义如下表1-2所示。
表1.2 常见请求头项

| 请求头项            | 说明                  | 示例                                              |
|-----------------|---------------------|-------------------------------------------------|
| Accept          | 声明客户端接受的内容类型        | Accept: application/json;                       |
| Accept-Charset  | 声明客户都浏览器可接受的字符编码集   | Accept-Charset: iso-8859-5                      |
| Accept-Encoding | 声明客户都浏览器支持内容压缩格式    | Accept-Encoding: compress，gzip                  |
| Accept-Language | 声明客户端浏览器可接受的语言      | Accept-Language: en,zh                          |
| Cache-Control   | 声明请求使用的缓存机制         | Cache-Control: no-cache或max-age=315360000       |
| Expires         | 声明缓存过期时间            | Sun，17 Oct 2027 14:03:47 GMT                    |
| Connection      | 声明是否使用持久连接          | Connection: keep-alive或closed                   |
| Cookie          | 该服务器域名存储到客户端本地的标记信息 | Cookie: JSESSIONID=....;                        |
| Content-Type    | 声明请求内容类型            | Content-Type: application/x-www-form-urlencoded |
| Content-Length  | 请求内容长度              | Content-Length: 248                             |
| Host            | 服务器域名及端口号           | Host: www.baidu.com                             |
| Referrer        | 声明先前网页的地址           | Referrer: https://www.baidu.com/                |
| User-Agent      | 声明客户端发送请求的软件信息      | User-Agent: Mozilla/5.0 (Linux; X11)            |
| Date            | 声明发送请求的日期和时间        | Date: Tue，15 Nov 2010 08:12:31 GMT              |
| Server          | 声明应用服务器信息           | Server: nginx                                   |

除常见的请求头外，程序也可以自定义一些请求头项用于验证或记录信息。大部分请求头项也应用与响应头。

#### 4．常见的内容类型（Content-Type）
内容类型（Content-Type）是请求头或响应头中对请求或响应数据格式的声明。一般如果有请求或响应数据，请求头或响应头中应指定相应的内容类型。
表1.3 常见内容类型

| 内容类型                              | 说明                         |
|-----------------------------------|----------------------------|
| text/plain                        | 纯文本格式                      |
| text/html                         | HTML文本格式                   |
| text/xml                          | XML文本格式                    |
| image/jpeg                        | JPEG图片格式                   |
| application/xml                   | XML应用格式                    |
| application/json                  | JSON应用格式                   |
| application/x-www-form-urlencoded | 纯文本Form表单经URL编码格式          |
| application/pdf                   | PDF格式                      |
| application/msword                | Word格式                     |
| application/octet-stream          | 二进制流数据格式                   |
| multipart/form-data               | 复合表单格式，纯文本变量数据与二进制文件数据混合格式 |

其中，纯文本表单application/x-www-form-urlencoded会将数据经URL编码后发送，text/plain、text/html、text/xml、application/xml、application/json会以原始（Raw）格式发送。image/jpeg、application/pdf、application/msword、application/octet-stream以二进制格式发送，而混合表单multipart/form-data则按文本和二进制数据混合格式发送。

> 注：application/xml与text/xml的区别 text/xml忽略xml头所指定编码格式而默认采用us-ascii编码，而application/xml会根据xml头指定的编码格式来编码。

5．请求数据（Request Body）
请求数据为请求中发给服务端的正式数据，长度不限，可以为空。常用的有表单格式，复合表单，原始格式及二进制四种格式。
表单格式，对应Content-Type: application/x-www-form-urlencoded。表单，即网页上由输入框，单选框，复选框，下拉框，提交按钮等组成的，用来收集用户信息的页面.
当表单不涉及上传文件时，一般将收集到的信息经过URL编码后传输. 如，在登录页面上输入用户名: 张三，密码:
123456后，请求数据经URL编码组装为以下格式(非ASCII码将会进行响应的转化)。

```
name=%E5%BC%A0%E4%B8%89&password=123456
```

复合表单格式，对应Content-Type: multipart/form-data。当表单中包含上传的文件时，一般使用复合表单格式，将文本格式的变量值即上传的文件的二进制格式组成多个部分作为请求数据传输。
原始格式，对应Content-Type:
text/plain、text/html、text/xml、application/json，application/xml等。前两种格式对原始数据进行了重新编码和组装，使用原始格式发送数据时，数据将使用数据的原始格式发送。在使用不同的数据格式时通用要在请求头中指定使用的内容类型(
Content-Type)。
如发送JSON格式的数据，Content-Type: application/json。

```json
{
  "name": "张三",
  "password": "123456"
}
```

XML格式的数据，Content-Type: application/xml

```xml

<xml>
    <msg>Hello</msg>
</xml>
```

二进制格式，对应Content-Type: application/octet-stream，主要用于流式上传文件。

### 1.3.4  HTTP响应

响应Response为服务端返回给客户端的报文信息。通常由状态行、响应头，和响应数据组成，响应原始数据9所示：

```txt
HTTP/1.0 200 OK
Date: Mon, 11 Jan 2021 09:25:00 GMT
Content-Type: application/json
Content-Length: 361
Connection: keep-alive
Server: gunicorn/19.9.0
Access-Control-Allow-Origin: *
Access-Control-Allow-Credentials: true
{
  "args": {
    "age": "12",
    "name": "Kevin"
  },
  "headers": {
    "Accept": "*/*",
    "Accept-Encoding": "gzip, deflate, br",
    "Cache-Control": "no-cache",
    "Host": "httpbin.org",
    "X-Amzn-Trace-Id": "Root=1-5ffc196c-23bd60c65d2a48c33ead9700"
  },
  "origin": "111.194.126.253",
  "url": "https://httpbin.org/get?name=Kevin&age=12"
}
```

响应报文同样分为三个部分：

1. 状态行：第一行，包含HTTP协议版本、状态码及状态码解释。
2. 响应头: 第二至N行（空行之前），响应信息的辅助声明。
3. 响应数据：响应数据

#### 1．状态码（Status Code）
   状态码是用来表示响应状态的一种统一的编码，由3位数字组成，按开头数字可分为以下5类：
1. 1**：信息，服务器收到请求，需要请求者继续执行操作。
2. 2**：成功，操作被成功接收并处理。
3. 3**：重定向，需要进一步的操作以完成请求。
4. 4**：客户端错误，请求包含语法错误或无法完成请求。
5. 5**：服务器错误，服务器在处理请求的过程中发生了错误。
   常见状态码如表1.4所示：
   表1.4 常见状态码说明

| 状态码 | 原因                    | 说明        |
|-----|-----------------------|-----------|
| 200 | OK                    | 成功        |
| 201 | Created               | 创建成功      |
| 204 | Not Connected         | 资源删除成功    |
| 301 | Moved Permanently     | 永久重定向源    |
| 302 | Moved Temporarily     | 临时重定向     |
| 400 | Bad Request           | 客户端请求语法错误 |
| 401 | Unauthorized          | 请求未授权     |
| 403 | Forbidden             | 资源没有访问权限  |
| 404 | Not Found             | 请求资源不存在   |
| 405 | Method Not Allowed    | 请求方法不被允许  |
| 500 | Internal Server Error | 服务器内部错误   |
| 502 | Bad Gateway           | 网关失效      |
| 504 | Gateway Timeout       | 网关请求超时    |

#### 2．响应头（Response Headers）
响应头即响应数据的辅助信息，部分响应头字段与请求头相同，如Content-Type、Content-Length、Server、Date等等，有一个不同的是，响应头可以包含Set-Cookie字段，用于向客户端存储该域名对于客户端的Cookies标记信息。

#### 3．响应数据（Response Body）
同请求数据一样，响应数据也可以根据Content-Type来指定不同格式的响应数据，如text/plain、text/html、application/xml、application/json、image/jpeg等。

#### 4．常见字符集及数据编码格式
有时我们在解析响应时会遇到乱码的现象，这是因为响应使用的字符集（Charset）与解码使用的编码集不同导致。常见的字符集及编码格式有以下几种：

1. ASCII码：单字节，美国信息交换标准码，包含数字，字母，英文标点及一些控制字符。
2. ISO-8859-1：又称Latin1，单字节，向下兼容ASCII，用于支持部分于欧洲使用的语言。
3. ANSI编码：单字节表示英文，双字节表示汉字，对ASCII的扩展，不同的国家和地区制定了不同的标准，中文中的GBK，GB2312属于ANSI编码。
4. Unicode编码：采用二个字节编码（英文和中文的字符都以双字节存放），与ANSI码不兼容
5. UTF-8：是目前互联网上使用最广泛的一种Unicode 编码方式，又称万国码。
6. URL编码：URL编码，对非ASCII码及特殊字符进行转码，常用于URL，查询参数，及x-www-form-urlencoded格式的表单数据。
7.
Base64编码：一种用64个字符来表示任意二进制数据的方法。Base64编码的作用：由于某些系统中只能使用ASCII字符。Base64就是用来将非ASCII字符的数据转换成ASCII字符的一种方法，适合在HTTP、MIME协议下快速传输数据。

### 1.3.5  常见接口鉴权机制

为验证用户身份，接口需要采用一定的鉴权机制，常见的接口鉴权机制有Cookie/Session机制，Ap Key/Token机制，开放授权协议等。

1. Cookie/Session机制
   即需要登录，登录后可访问各个接口，最常用的一种策略，适用于内部接口。
   Session与Cookies的区别如下：
1. Cookie是存在客户端（浏览器）的进程内存中和客户端所在的机器硬盘上，Session存在服务器端，存在网站进程的内存中。
2.
Cookie只能能够存储少量文本，大概4K大小，Session在初次设置Session的时候，会在Session池中实例化一个Session对象，以“sessionid”的值作为Key，同时会将Key以Cookie的形式保存到客户端的内存中。
3. Cookie是不能在不同浏览器之间共享，Session的作用域只存在当前浏览器的会话中，当浏览器关闭以后就会将“sessionid”丢失，但是服务器的Session对象并不会立即回收。
   2.Token机制
   Token即身份令牌。用户访问接口前先获取Token令牌，再携带Token（例如在URL参数或请求头中携带）请求接口，同时Token也具有一定有效期。
   另外还有一种基于固定AppKey的鉴权机制。用户注册时会生成一个唯一的AppKey，用户调用接口时需要携带AppKey，适用于公开接口，安全性较差。
   Token与Session机制的区别如下：
1. Session是一种基于状态的机制，服务端需要维护大量的用户Session，占用大量的资源，服务端通过客户端请求Cookie中携带的Session
   ID是否在维护的Session池中来鉴别用户是否为登录状态，由于Cookie基于域名存储，不同域名的分布式系统往往还需要解决跨域问题。
2. Token是基于算法生成和验证的，服务端不需要存储Token值，只需要通过固定的算法和秘钥来验证Token即可。Token机制是无状态的，更利于分式系统使用。
3. Session和Token都有一定的有效期，都是比较安全的。
   3.开放授权协议
   标准的接口授权协议，如Basic Auth、Digit Auth、OAuth 2.0等，适用于开发者平台等开放数据接口。
   4.其他
   如IP白名单机制等，运维通过见请求方法IP加入白名单来允许客户端访问。

## 1.4  Chrome 开发者工具抓包

Chrome开发者工具是Chrome浏览器自带的一款开发调试工具，可以查看页面元素，调试JavaScript脚本，网络抓包，进行网页性能诊断等非常强大的功能，并且使用非常方便。
在在页面上按Ctrl+Shift+I或Command+Option+I便可以快速打开Chrome开发者工具，如图1.2所示。
图1.9 Chrome 开发者工具
Chrome开发者工具包含9个面板，从左至右依次为Elements：元素面板，Console：JavaScript控制台，Sources资源面板，Network：请求信息面板，Performance：网站声明周期性能面板，Memory内存占用分布面板，Application：本地存储、会话管理等应用面板，Security安全验证面板，Audits：综合审计面板，本节重点讲解用于查看请求的Network：请求信息面板。

### 1.4.1  Network请求信息面板

如图1.2，Network请求信息面板从上到下分为工具栏、过滤器、请求列表和状态栏4个部分。

#### 1．工具栏
工具栏各按钮、选项功能说明，参见表格2.1
表格2.1 Network工具栏

| 按钮/选项         | 说明                               |
|---------------|----------------------------------|
|               | 开启/关闭请求捕获                        |
|               | 清空请求列表                           |
|               | 显示/隐藏过滤器工具栏                      |
|               | 搜索请求                             |
| Preserve log  | 当页面跳转时保持之前记录                     |
| Disable cache | 禁用缓存                             |
| Online        | 网络选项，可以模拟离线和弱网                   |
|               | 导入请求HAR包                         |
|               | 导出请求HAR包                         |
|               | 额外设置，比如使用大请求行、按帧分组、显示概览和捕获页面加载截图 |

#### 2．过滤器
过滤器是用来过滤请求的，当请求较多时，通过过滤可以快速找到我们需要的请求。
过滤器第一个是过滤框，可以通过部分字符快速匹配出请求名称中包含该字符的请求，如输入www.baidu可以过滤出名称中包含www.baidu的请求。
另外，过滤器支持多种过滤语法，常用示例如下：

- domain:*.baidu.com：按域名过滤
- method:GET：按请求方法过滤
- mime-type:application/json：按数据类型过滤
- scheme:https：按协议类型过滤
- status-code:200：按状态码过滤
- set-cookie-doman:www.baidu.com：向www.baidu.com这个域名下设置了Cookie的请求
- set-cookie-name:sessionid：设置了名为sessionid的Cookie的请求
- has-response-header:token: 响应中包含指定请求头项的请求
  多种过滤表达式之间可以使用And连接。
  Hide data URLs选项可以不显示data：开头的嵌入式小型文件（如svg）请求。
  后面是按类型过滤，参考表格2.2
  表格2.2 过滤类型

| 名称       | 说明                     |
|----------|------------------------|
| ALL      | 显示所有类型请求               |
| XHR      | 仅显示AJAX请求              |
| JS       | 仅显示JS资源请求              |
| CSS      | 仅显示CSS资源请求             |
| Img      | 仅显示图片资源请求              |
| Media    | 仅显示音视频媒体类型             |
| Font     | 仅显示字体资源请求              |
| Docs     | 仅显示文档类型(如HTML)资源请求     |
| WS       | 仅显示Web Socket类型请求      |
| Manifest | 仅显示带有缓存manifest的HTML文档 |
| Other    | 仅显示其他类型请求              |

我们可以通过对应的类型，如XHR快速过滤出数据类型的请求。

#### 3．请求表格
请求表格默认按请求时间排序，也可以点击对应的列名按指定列排序。请求表格从左到右分别为Name（资源名称）、Status（状态码）、Initiator（请求源）、Size（资源大小或来自缓存）、Timeline（网络请求时间轴状态）。
> 注：导出请求方法，右击请求 -> Copy -> Copy as fetch / Copy as cUrl

#### 4．状态栏
状态栏主要显示请求总数、数据传输量和加载时间能信息。其中，DOM Content
Loaded为页面上DOM完全加载并解析完毕的时间，Load为页面上所有DOM、CSS、JS、图片完全加载完毕的时间。

### 1.4.2  查看请求

点击Chrome开发者工具Network面板的会话列表，查看请求详情，如图2.5所示。
图1.10 查看请求详情
如上图，General中为请求的概要信息，Request URL是请求的URL地址，Request Method是请求方法，Status Code是响应状态码。下面分别是Response
Headers响应头和Request Headers请求头等信息。
查看请求出要关注以下信息：

### 1.4.3 复制及导出请求

如果需要将保存请求或者发送给其他人，可以在请求上点右键选择复制，一般建议复制为cURL格式（即curl命令格式）。如图2.6所示。
图 1.11 复制及导出请求
如果要导出完整的请求及响应数据，也可以点击工具栏上的向下箭头，导出har格式的请求（har实际上是基于JSON的一种格式，可以使用文本文件打开查看）。

## 1.5  Fiddler使用

Fiddler是一款免费的Windows平台的抓包工具，功能强大，使用简单。Fiddler抓包基于中间人代理模式，工作原理如图1.12所示。
图1.12 中间人代理抓包
Fiddler在启动时会自动设置系统代理，Chrome浏览器等程序访问网页或发送HTTP请求时，便会自动经过Fiddler发送给服务端，因此Fiddler中便能查看到所有当前PC发送的所有HTTP请求。
Fiddler主要特点如下：

1. 可以抓到请求数据，查看Raw格式/表单格式/JSON/XML格式.
2. 可以拦截和修改请求.
3. 更强大的过滤器。
4. 可以抓取Postman/接口脚本发送的请求，方便调试。
5. 可以抓包手机请求。
   1．Fiddler主界面
   Fiddler的主界面分为菜单栏、工具栏、请求列表、快速命令栏、监控面板及状态栏等，如图1.13所示。
   图1.13 Fiddler主面板
   Fiddler菜单栏包括File（文件）、Edit（编辑）、Rules（规则）、Tools（工具）、View（显示）及Help（帮助）。
   Fiddler工具栏包括WinConfig（Windows配置）、、Replay（重放）、清理、Go（拦截放行）、Stream（流）、Decode（解码）、Keep: All
   sessions（请求会话保持）、Any Process（抓取进程）、Find（查找）、Save（保存）、、Browse（浏览器选择）及Clear Cache（清除缓存）。
   主体区左侧为请求列表，又称会话列表（客户端与服务端的一次交互被称为一次会话过程）。请求列表中使用不同的图标区分不同类型的会话类型，常见的会话类型如表2.1所示。
   表2.1 Fiddler会话类型

| 图标 | 类型     | 说明                         |
|----|--------|----------------------------|
|    | 请求方法   | POST请求                     |
|    | 请求方法   | HEAD请求                     |
|    | 请求方法   | CONNECT请求，HTTPS握手通道        |
|    | 响应数据类型 | text/html类型                |
|    | 响应数据类型 | application/json类型         |
|    | 响应数据类型 | application/xml或text/xml类型 |
|    | 响应数据类型 | 身份验证凭据类型                   |
|    | 响应数据类型 | CSS文件                      |
|    | 响应数据类型 | JavaScript脚本文件             |
|    | 响应数据类型 | 字体文件                       |
|    | 响应数据类型 | 图片文件                       |
|    | 响应数据类型 | 音频文件                       |
|    | 响应数据类型 | 视频文件                       |
|    | 响应数据类型 | FLASH文件                    |
|    | 响应数据类型 | Silverlight应用              |
|    | 状态码    | 2**，成功                     |
|    | 状态码    | 3**，重定向                    |
|    | 状态码    | 304，使用缓存文件                 |
|    | 状态码    | 4**，客户端错误                  |
|    | 状态码    | 5**，服务端错误                  |
|    | 会话过程   | 请求正在发送到服务端                 |
|    | 会话过程   | 响应正在从服务器下载                 |
|    | 会话过程   | 请求被拦截（请求断点）                |
|    | 会话过程   | 响应被拦截（响应断点）                |

> 注：以上表格使用新版Fiddler的会话图标，HTML格式、XML格式、CSS、脚本、图片等图标与老版本略有不同。

请求图标可以帮助我们快速识别各种类型的请求或相应，GET方法的请求根据不同的响应数据类型显示不同的图标，POST等方法按请求方法类型显示对应的图标。对于数据量比较大的请求，会在请求和响应的过程中或显示为上传和下载的图标，当使用断点拦截请求或响应时，上传、下载图标显示为暂停的样式。

### 1.5.1  请求抓包

抓取请求是Fiddler的主要功能之一，Fiddler在启动时会自动设置系统代理，因此只要打开Fiddler就可以正常抓取当前PC端的HTTP请求。要抓取HTTPS请求或移动端请求则要进行相应的配置。

#### 1．抓取PC端HTTPS请求

打开浏览器访问https://www.baidu.com/查看Fiddler中抓取的请求，如图1.14所示。
图1.14 未安装证书时的HTTPS请求
未设置和安装证书时抓取到的HTTPS请求显示为锁型图标的HTTP CONNECT请求，转发到对应网站的443端口。
抓取HTTPS请求需要现在设置中勾选捕获HTTPS连接及解密HTTPS数据。操作方法是，点击菜单栏Tools（工具），选择Options（选项），切换到HTTPS面板，如图1.15所示。
图1.15 Fiddler HTTPS选项设置
如上图，勾选Capture HTTPS CONNECTs（捕获HTTPS连接）、Decrypt HTTPS traffic（解密HTTPS数据）和Ignore server certificate
errors（unsafe）（忽略服务端证书错误）。由于我们需要使用Fiddler提供的免费证书，有可能服务端或报证书错误，忽略即可。
安装Fiddler提供的HTTPS证书。安装方法非常简单，启动Fiddler后，打开浏览器，访问http://localhost:8888/，如图1.16所示。
图1.16 下载Fiddler证书
点击页面下方的链接FiddlerRoot certificate，下载完成后双击打开，点击安装证书，一路下一步使用默认选项安装即可，安装结束后会弹出提示导入成功。
重启Fiddler，重新访问https://www.baidu.com/，如图1.17所示。
图1.17 Fiddler抓取HTTPS请求
这时可以抓取到HTTPS类型的请求。点击该请求，右侧点击Inspectors面板，上半部分为请求信息，下半部分为响应信息。木偶人响应信息已编码过，点击Responsebody
is encoded.Click to decode.解码查看，选择Raw格式，可以查看到返回的百度网页的源码。

> 注：如果抓不到包可以检测一下是否勾选了Filter过滤器。
> 强制关闭Fiddler会导致代理不能正常取消，Fiddler却已关闭，而无法上网的情况。此时重新打开Fiddler，然后正常关闭一次即可自动取消代理。

#### 2．抓取移动端请求

抓取手机端App发送的HTTP或HTTPS请求，需要手动在手机端设置网络代理为Fiddler代理服务地址，即使手机通过Fiddler代理上网，才能抓取到。
首先手机要与电脑在同一局域网内，比如同一Wi-Fi网络上网。电脑端启动Fiddler（自动启动代理服务，默认端口号为8888），使用ipconfig或ifconfig查看电脑的IP地址，如192.168.1.3，那么Fiddler代理服务的地址即192.168.1.3:
8888。
Fiddler中点击菜单栏Tools（工具），选择Options选项，切换到Connections选项卡，勾线Allow remote computers to
connect，已允许远程设备连接Fiddler代理服务，如图1.18所示。

图1.18 Fiddler代理服务连接设置
打开手机设置，找到所连接的Wi-Fi网络，选高级（iPhone手机点击Wi-Fi网络后面的圈i图标），配置代理，选择手动，IP地址和端口号分别配置为电脑IP地址和8888，点击保存（存储），如图1.19所示。

图1.19 手机配置代理
使用手机浏览器访问http://电脑IP地址:8888（建议使用手机原生浏览器），会显示Fiddler Echo Service页面，同样点击FiddlerRoot
certificate，下载并安装证书。安装完证书后，iPhone手机还需要对证书进行信任，手机设置中点击通用，点击关于本机，点击证书信任设置，设置信任DO_NOT_TRUST_FiddlerRoot证书，返回即可。
此时保持Fiddler打开，使用手机浏览器浏览网站或使用App请求即可，如弹出HTTPS证书不被信任警告，忽略即可。

> 注：设置完代理有，由于手机需要通过Fiddler代理上网，如果Fiddler关闭手机会连不上网。不抓包时可以在手机设置中把配置代理取消掉。

### 1.5.2  请求查看

在Fiddler请求列表中点击相应请求，右侧选择Inspector选项卡，可以查看请求及响应的详细内容，上半部分为请求，下半部分为响应。请求和响应可以使用子选项卡查看不同的内容及格式，对应说明如表格2.2及2.3所示。
表2.2 Inspector请求子选项卡

| 子选项卡       | 说明             |
|------------|----------------|
| Headers    | 查看请求头          |
| TextView   | 以文本格式查看请求数据    |
| SyntaxView | 以语法格式查取请求数据    |
| WebForms   | 查看表单格式请求数据     |
| HexView    | 以16进制格式查看请求数据  |
| Auth       | 查看请求授权信息       |
| Cookies    | 查看请求Cookies数据  |
| Raw        | 查取原始HTTP请求格式数据 |
| JSON       | 查看JSON格式请求数据   |
| XML        | 查看XML请求格式数据    |

一般可以使用Raw查看原始的请求数据，如果是表单类型的请求，可以使用WebForms查看表单类型的数据，如果是JSON或XML格式可以使用对应的子选项卡查看。
表2.3 Inspector响应子选项卡

| 子选项卡        | 说明            |
|-------------|---------------|
| Transformer | 选择数据解压格式      |
| Headers     | 查看响应头         |
| TextView    | 以文本格式查看响应数据   |
| SyntaxView  | 以语法格式查看响应数据   |
| ImageView   | 以图片格式查看响应数据   |
| HexView     | 以16进制格式查看响应数据 |
| WebView     | 以网页格式查看响应数据   |
| Auth        | 查看响应授权信息      |
| Caching     | 查看缓存数据        |
| Cookies     | 查看响应Cookies数据 |
| Raw         | 查看原始响应数据      |
| JSON        | 查看JSON格式响应数据  |
| XML         | 查看XML格式响应数据   |

HTTP数据一般是经过压缩传输的，Transformer一般使用默认的即可。可以通过Raw来查看原始响应数据或按照相应的数据类型选择对应的格式查看。

### 1.5.3  过滤请求

Fidller提供过滤器（Filters）功能，当请求较多时，使用Filter组件可以帮我们快速过滤出指定的请求。要启用过滤器，首先要右侧Filters选项卡中勾选Use
Filters，如图1.20所示。
图1.20 启用Fiddler过滤器
Fiddler支持的过滤方式如下：

- Hosts：按服务器过滤。
- Clients Process：按客户端程序过滤。
- Request Headers：按请求头过滤。
- Breakpoints：设置断点。
- Response Status Code：按状态码过滤。
- Response Type and Size：按响应类型及大学过滤。
- Response Headers：按响应头过滤。
  例如，可以在Hosts段第二个下拉框选择Show only the following
  Hosts，在下面的文本框中设置要显示域名，以分号分开，如www.baidu.com;www.163.com，就可以只显示发往这两个域名的请求。

> 注：启用关闭过滤器有时需要重启后方能生效。

### 1.5.4  调试请求及端点调试

Fiddler支持对于抓到的请求要进行重放，并提供调试器来发送请求（类似Postman功能），同时Fiddler还支持对请求和响应进行断点（拦截）以及篡改原始请求或响应数据进行调试。

#### 1.请求重放

Fiddler支持对抓取到的请求进行重放。操作方法为在请求列表区域，指定请求上，点击右键，选择Replay，选择Replay
Sequencely，输入要重放的次数即可。

#### 2.调试器（Composer）

Fiddler的Composer选项卡可以用来发送和调试请求，如图1.21所示。
图1.21 Fiddler请求调试器Composer
Composer可以用于发送HTTP请求，功能比较简单，表单格式数据需要自己进行URL编码，填写完成后点击Execute发送即可。请求会以会话的形式显示在请求列表中，同事History历史记录中会有响应的记录。

#### 3.断点调试

当我们需要详细抓取并调试某个接口的数据时，可以使用Fiddler的断点调试功能。Fiddler的断点调试设置方式有两处，一是Filter过滤器中对指定特征的请求自动进行断点拦截，另一种是对所有请求设置断点，设置方式为：菜单Rules ->
Automatic Breakpoints -> Before Requests/After Responses。断点分为两种方式，一种是Before
Requests请求前拦截，即请求未发送到服务器之前拦截。一种是After
Responses，服务端响应未送达客户端时拦截，一般我们使用第一种，如图2.12，被断点拦截的请求会显示为暂停图标。此时可以在Inspector中修改其数据，然后点击Go按钮，使用修改后的数据完成请求。

> 注：如果线上环境中不希望请求数据（如提交订单或支付信息）真实发送到服务器，同时又需要对请求进行抓包，也可以使用断点功能。

### 1.5.5 修改HOSTS及自动响应

在只有前端，后端服务还不具备的时候，Mock和重定向接口是一种常见的操作。使用Fiddler可以直接配置修改系统的HOSTS来讲服务转向另一台服务器。对于单独的接口，也可以使用Fiddler的自动响应功能来自己设计返回的响应数据来达到Mock的功能。
1.修改系统HOSTS
在Fiddler中还可以快速修改HOSTS配置，操作方法为点击惨淡Tools -> HOSTS，设置保存即可。
2.自动响应（AutoResponder）
Fiddler的Anto Reponder选项卡可以根据一定的规则对匹配到的请求进行自动响应或转向其他的接口或文件。如图1.22所示。
图1.22 Fiddler使用Autoreponder
勾选Enable rules启用匹配规则，勾选Unmatched requests passthrough对未匹配到的请求正常放行。

### 1.5.7  弱网模拟

弱网模拟是App测试中一个常用测试项。Fiddler菜单中的弱网模拟功能，只有模拟非常慢的模拟Modem调制解调器上网速度一个选项，设置方式为Rules ->
Performance->Simulate Modem Speeds。
更精确的网速控制需要通过Fiddler Script实现。

## 1.6  Postman使用

Postman是一款简单方便的接口调试工具，便于分享和协作。具有接口调试、请求集管理、环境配置、参数化、断言、批量执行、请求录制、Mock
Server,、接口文档、接口监控等功能。

### 1.6.1  Postman主界面

Postman主界面分为菜单栏、工具栏、请求管理区、环境管理区、请求设计区及状态栏等主要部分组成，如图1.23所示。
图1.23 Postman主界面

#### 1．菜单栏

Postman菜单栏由File（文件）、Edit（编辑）、View（显示）和Help（帮助）4个主菜单组成。

#### 2．工具栏

Postman的工具栏中是一些常用的工具按钮如新疆、导入、运行器等等。详细按钮及解释参考表2.4。
表2.4 Postman工具栏按钮功能

| 按钮     | 说明                                           |
|--------|----------------------------------------------|
| New    | 新建，可以新建Request请求，Collection请求集，环境等等          |
| Import | 导入，可以导入别人导出的请求集                              |
| Runner | 运行一个请求集（批量执行）                                |
| 窗口+    | 新建Tab页或窗口                                    |
| Invite | 邀请（需要注册，邀请进行协作）                              |
| 同步     | 同步你的项目到云端（需要注册）                              |
| 代理     | 抓包/捕获请求，用于开启Postman代理，手动设置代理（或手机代理）后可抓包/录制请求 |
| 设置     | Postman设置                                    |
| 消息     | 官方及协助消息                                      |
| 收藏     | 我的收藏（需要注册）                                   |
| 云端     | 用户云端数据（需要注册）                                 |

#### 3．请求管理区

请求管理区位于Postman主体的左侧，用于查看保存的请求列表或请求历史。主要分为Collections接口集和History请求历史两种视图。
接口集，相当于一个接口项目或测试计划，接口集中可以建立无限极子文件夹，用于对接口进行分组管理。请求历史记录视图中可以查询到之前的请求记录。

#### 4．环境管理区

环境管理区分位于Postman主体右侧请求设计区右上角。由一个环境选择下拉框，一个眼睛（预览）图标和一个环境设置图标组成。环境选择下拉框中可以切换不同的环境。环境预览按钮可以快速雨来环境中的所有变量设置。环境设置中可以添加修改环境变量以及全局变量。
注：什么是环境？
环境是一套配置，包含许多环境变量。在接口测试中，根据部署在不同的服务器上，服务器地址有可能不同，而同一个接口，接口地址是不变的。为了测试部署在不同服务器上的同一套接口，我们可以建立不同的环境，不同环境中host变量使用不同的地址。

#### 5．请求设计区

请求设计区位于Postman右侧，是Postman的核心功能区。请求设计区上半部分为请求区，下半部分为响应区。可以通过上方的Tab选项卡边上的+好，新建多个请求面板，如图1.24所示。
图1.24 Postman请求设计区
请求区主要由请求地址行和请求数据区组成。
请求地址行中可以选择请求方法（GET/POST/...），填写请求地址，发送请求和保存请求到测试集。
请求数据区：分为授权，请求头，请求数据，请求发送前执行的脚本（用于准备数据），请求结束后执行的脚本（用于断言）。
请求设计区分为以下5个面板。

- Params：URL参数。
- Authorization：如果接口需要授权，可以在该页面设置授权方式（type）和授权信息。
- Header：请求头，可以设置请求类型（Content-Type）和Cookie。
- Body：请求数据。
- Pre-request Script：请求前脚本，JavaScript语法，用于在发送请求前生成一些动态数据或做一些处理
- Tests：请求后脚本，JavaScript语法，用于请求返回后做一些处理或断言结果
  其中Body下主要包含以下4中格式。
- form-data：混合表单，支持上传文件
- x-www-form-urlencoded：文本表单
- raw：原始格式，支持JSON/XML格式（后面可选择）
- binary：二进制格式，用于发送二进制数据流
  选择不同的格式，可以发送不同类型的请求数据。
  响应区用于展示发送完请求，服务端的响应数据及状态，由Body响应体、Headers响应头、Cookie响应Cookies、Test Results测试结果4部分组成。
  响应内容中可以以Pretty（美化格式）、Raw（原始格式）、Preview（HTML预览格式）等方式查看响应数据。测试结果用于显示请求中Tests中设置的断言的测试结果。

### 1.6.2  发送请求

#### 1．发送GET请求

发送GET请求非常简单，请求方法使用默认GET，在地址栏中填入接口地址，点击发送即可，如图1.25所示。
图1.25 Postman发送GET请求
请求URL参数可以直接写在URL中，也可以通过Params选项卡中的表格填写，参数会自动同步到URL中。
> 注：如果请求需要登录，可以先在Postman其他Tab页的请求中发送登录接口进行登录（Postman会保存登录的Cookies），然后再发送该GET请求。或者抓取登录后的Cookies，填写到该GET请求的Header中。

#### 2．发送表单格式POST请求

表单格式的非常常见的一种网页表单提交的格式。对应的内容类型为application/x-www-form-urlencoded。参数数据经过URL编码后发送。
在Postman中发送表单格式的数据，首先要在地址行中选择POST方法，填写接口地址，选择下方的Body（请求体）子选项卡，选择x-www-form-urlencoded格式，在表格中填入参数数据，点击Send发送即可。如图1.26所示。
图1.26 Postman发送表单格式POST请求

> 注：在选择x-www-form-urlencoded格式后，Postman会自动在请求头中添加对应的内容类型项，Content-Type:
> application/x-www-form-urlencoded。

#### 3．发送JSON格式POST请求

JSON格式属于raw原始格式（即不经过编码原样发送）中的一种。发送JSON格式请求，首先选择POST请求方法，填写接口地址，选择Body请求体，选择raw，在右侧的下拉选项中选择JSON（application/json）。在下方输入JSON格式的请求数据，点击发送即可，如图1.27所示。
图1.27 发送JSON格式POST请求

> 注：输入的JSON数据要符合JSON语法格式，只能用双引号，不能用单引号，不支持注释等。如果格式错误，对应行数字后会有相应的x号标记。
> 在选择完raw->JSON（application/json）后，Postman会自动在请求头中添加内容类型声明Content-Type: application/json。

#### 3．发送XML格式POST请求

XML格式的请求同样属于raw原始格式的一种。选择POST请求方法，填写接口地址，选择Body请求体，选择raw，在右侧的下拉菜单中选择XML，application/xml或text/xml均可。如图1.28所示。
图1.28 发送XML格式POST请求
同样，在选择为XML格式后Postman会在请求头中添加对应的内容类型声明。

#### 4．发送文件上传类型的请求

文件上传请求一般采用multipart/form-data混合表单格式。每个文件同样对应一个参数变量。在Postman里Body请求体重选择form-data格式，填写对应的参数变量，点击该参数单元格右侧的下拉小箭头中选择File（文件），在后面的单元格中点击选择文件即可。如图1.29所示。
图1.29 使用Postman上传文件
如果需要上传多个文件，填写多个变量即可，也可以填写普通Text（文本）变量。

### 1.6.3  响应

在编辑完请求后点击发送即可收到响应。响应区分为Body响应体、Cookies响应Cookies、Headers响应头和Test
Results测试结果。右侧还包含Status状态码、Time响应时间和Size数据大小三组数据。
响应数据可以使用Pretty美化格式（通常用于JSON或XML格式的响应数据）、Raw原始格式和Preview预览格式（一般用于预览HTML网页），后面还可以设定数据的格式来进行Pretty美化展示。
换行图标可以将单行的响应数据按树状格式多行显示。右侧为复制、字段搜索和Save Response保存响应3个按钮。

### 1.6.4  环境和变量

变量用于对请求数据进行参数化。环境则为一套变量配置。通过在请求中使用参数化变量，加上切换环境可以快速批量改变请求中的某些参数值，如base_url接口地址。

#### 1．环境变量设置

点击环境管理区的环境设置图标，可以打开环境管理对话框，点击添加按钮或已存在的环境名可以新建或修改环境。如图1.30所示。

图1.30 新建环境并添加变量

#### 2．环境变量使用

在环境选择下拉框选择指定环境，在请求URL或者请求Body里使用{{变量名}}来使用指定的环境变量。如图1.32所示。

图1.32 使用环境变量

变量可以在请求Body的各种格式中使用，但不能直接在请求前脚本（Pre-request Script）和请求后脚本（Tests）中使用。

#### 3．全局变量

环境管理中还可以点击“GLOBAL”按钮添加全局变量.环境变量只有当选择了该环境时生效，全局变量在任何环境中生效。如果全局变量和环境变量名有重复，环境变量的优先级大于全局变量。

> 注：测试集Collection中也有Variables集合变量，只对保存在当前Collection中的请求生效。三种变量的优先级关系为环境变量>
> 全局变量>集合变量。

### 1.6.5  测试脚本及断言

断言是指预期结果与实际结果的对比。包含断言的请求才能称得上是完整的测试用例。
Postman每个请求中都包含一个Tests选项卡，称为测试脚本，在收到响应后执行。在Tests测试脚本中可以对响应数据进行提取并添加断言。
Tests脚本区右侧会提供很多常用的SNIPPETS代码段，只要点击对应的代码段即可快速实现指定的功能或断言。

#### 1．状态码断言

状态码断言是最基本的断言之一，可以用于断言响应是否成功返回（状态码200）。
切换到请求的Tests测试脚本面板，在右侧SNIPPETS代码段中找到Status code: Code is 200并点击。Tests脚本中会出现以下代码。

```js
pm.test("Status code is 200", function () {
    pm.response.to.have.status(200);
});
```

其中Status code is 200是该断言的标题，pm.response.to.have.status(200);是具体的断言语句，如果要断言其他状态码可以修改括号中的200为对应的状态码。

#### 2．包含文本

Tests脚本中可以添加多条断言。要断言响应文本在代码段中点击Response body: Contains string，Tests脚本中会出现以下代码。

```js
pm.test("Body matches string", function () {
    pm.expect(pm.response.text()).to.include("string_you_want_to_search");
});
```

修改include括号中为实际应包含的字符串即可。

#### 3．JSON数据断言

JSON数据断言要先将文本格式的请求数据转换为JSON对象，然后根据JSON机构提取对应的字段进行对比。
在代码段中点击Response body: JSON value check。Tests脚本中会出现以下代码段。

```js
pm.test("Your test name", function () {
    var jsonData = pm.response.json();
    pm.expect(jsonData.value).to.eql(100);
});
```

var jsonData = pm.response.json();是将请求体数据转换为JSON对象赋给jsonData变量。pm.expect(jsonData.value).to.eql(100)
;为从JSON数据中提取第一级的value值请判断是否等于100。这里要修改value为对应要提取的字段，100改为对应的值。多个字段的断言可以写多个相同结构的断言，也可以写到同一个断言中使用多条pm.expect(
jsonData.字段名).to.eql(期望值);语句。多层字段使用点来逐级提取。

#### 4．运行测试

在请求Tests添加完断言后，点击发送，在响应的Test Results处就可以看到各条断言的结果。

### 1.6.6  请求集

对应常用的请求我们可以保存到Collection请求集中。点击请求右侧的Save按钮或按Ctrl+S即可弹出保存请求的对话框，输入请求名称，选择Collection集合点击保存即可。
Collection请求集用于组织和管理请求，Collection可以视为一个顶级的测试套件或测试计划。Collection中可以建立多层Folder子文件夹，来对请求进行分组管理。
Collection是Postman中接口管理的一个“整体”单位，运行、导出、分享等都是基于测试集的。
点击工具栏New按钮，选择Collection或者直接点击测试集列表上方的New Collection按钮即可弹出新建Collection界面。如图1.33所示。

图1.33 新建Collection请求集
Collection请求集包含名称、Description描述、Authorization授权、Pre-request Scripts请求前脚本、Tests测试脚本和Variables集合变量几部分组成。
在已存在的请求集上点击右侧的...按钮还可以对该请求集进行编辑、Add Folder建立子文件夹或进导出等其他操作。

### 1.6.7  批量运行Collection Runner

点击工具栏的Runner按钮或Collection右侧的三角按钮可以打开Collection
Runner集合运行器窗口。集合运行器可以批量运行一个Collection或Folder中的所有请求。并根据请求中的断言信息判断请求通过与否。同时Collection
Runner还支持设置迭代次数以及使用CSV或JSON文件进行数据驱动。
以下为使用Collection Runner及CSV文件进行数据驱动的一个完整示例。

1. 新建一个Collection，比如名称Demo2
2. 新建请求，填入URL：https://demo.fastadmin.net/admin/index/login.html，选择POST方法
   Body请求数据格式选x-www-form-urlencoded，请求数据填写username {{username}} password
   {{password}}，这里使用了两个变量来做参数化，然后在请求Tests中添加状态码断言。然后保存请求到Demo2中。如图1.34所示。
   图1.34 添加并保存请求
3. 使用数据文件。在电脑上新建一个data.csv文件，第一行为变量名，下面是数据，如图1.35所示。
   图1.35 新建带标题行的CSV文件
   其中标题行变量名要与请求中参数化的变量名一致。
4. 打开Collection Runner，选择请求集Demo2，点击Select File选择data.csv数据文件，点Run Demo2运行请求集。如图1.36所示
   图1.36 Collection Runner选择集合和数据文件
5. 运行完成后即可查看报告，如图1.37所示。
   图1.37 集合运行报告
   在测试报告页可以对报告进行Export Results导出、Retry重跑或New运行新的Collection。

> 注：如果请求中未在Tests中设置断言，通过数和失败数都会显示为0。

## 1.7  JMeter使用

在完成接口功能测试后，根据接口需求我们要对接口的性能进行测试。
JMeter是目前比较流行的开源性能测试工具。免费，灵活并支持众多插件。同时支持分布式压力测试。
JMeter以Test Plan(测试计划)为基本单位。Test Plan下添加线程组作为运行控制器。
Test Plan(测试计划）默认包含以下3种线程组。

- setup线程组： 可选，进行整个计划的测试准备
- 线程组：运行控制
- teardown线程组：可选，进行整个计划的测试清理
  JMeter中包含很多元件，常用元件及大致作用顺序如图1.38所示。
  图1.38 JMeter处理流程
  采样器是JMeter的核心元件，负责数据的发送和采集，如HTTP请求。在采样器前后可以添加前置处理和后置处理器，对请求数据进行预处理以及对响应数据进行变量提取操作。同时还可以在配置管理器类型元件中添加默认配置或使用数据文件等。
  断言元件用于对比响应结果和预期结果的对比，监听器用于查看响应及测试结果。

### 1.7.1  中文及编码设置

JMeter默认为英文界面，可以在菜单语言选项中临时切换为简体中文语言。想要永久生效可以修改JMeter安装目录bin目录中的jmeter.properties文件。
修改language属性值为zh_CN，并保存。同时为确保响应数据中的中文可以正常显示，可以修改sampleresult.default.encoding为UTF-8格式。如果1.39和1.40所示。
图1.39 JMeter 中文界面配置
图1.40 JMeter UTF-8编码配置
修改完配置后保存，重启JMeter即可。

### 1.7.2  发送请求

使用JMeter发送请求，只要使用采样器元件中的HTTP请求元件并填写对应的请求数据即可。
1．发送GET请求
首先在JMeter测试计划中添加线程组，线程组使用默认配置即可。在线程组上点击右键，选择采样器，选择HTTP请求，修改请求名为GET请求，填写协议、服务器地址、方法、路径及参数值，如图1.41所示。
图1.41 JMeter 发送GET请求
如果参数中包含中文，可以在内容编码处加上utf-8，同时在参数刚勾选编码（URL编码）。
如果想要查看响应结果，可以在线程组上点击右键，在监听器中选择结果树。点击工具栏上的三角按钮发送请求后，便可在请求树中看到响应的响应数据。

2．发送POST-表单格式请求
同样，发送POST请求需要添加采样器-HTTP请求元件，按需求填写请求数据，点击发送图标即可，如图1.42所示。
图1.42 JMeter 发送POST-表单请求
POST请求的参数表格对应请求体中的参数而不是URL参数，如果接口需要传递URL参数，可以填写到接口路径中。
同样，如果参数中包含中文，可以勾选上编码。发送完请求后，可以在结果树中查看响应结果，如图1.43所示。
图1.43 JMeter 结果树-查看响应数据
在结果树请求列表上方，可以切换显示格式（如切换为JSON格式），以相应的格式查看响应数据。同时也可以查看请求数据或响应头数据等。

3．发送POST-JSON格式请求
发送JSON格式的POST请求，首先添加采样器HTTP请求元件，填写请求数据，请求体数据切换到消息体数据，填写相应的JSON格式的数据，点击发送即可。如图1.44所示。
图1.44 JMeter 发送POST-JSON请求
消息体数据要符合JSON语法格式，否则文本框中对应行前会显示出错提示。如果消息体中包含中文，要声明内容编码为utf-8。

4．发送POST-XML格式请求
发送XML格式的POST请求与JSON一样，在消息体数据中填入XML格式的请求数据，点击发送即可。如图1.45所示。
图1.45 JMeter POST-XML请求
同样，消息体数据中如果包含中文，需要声明内容编码utf-8。

5．发送POST-上传文件请求
在HTTP请求元件的中可以通过文件上传选项卡发送上传文件类型的POST请求。首先添加HTTP请求元件，填写请求数据，勾选对POST使用multipart/form-data，点击浏览，选择文件上传，选择文件路径，填写对应的参数名称，和文件MIME类型，点击发送按钮即可。如图1.46所示。
图1.46 JMeter上传文件

> 注意要勾选上面的对POST请求使用multipart/form-data即混合表单格式。每个上传的文件一般对应一个参数，同时要填写文件格式对应的MIME类型。支持添加多个文件。

### 1.7.3  断言

断言是接口测试以及性能测试中必不可少的一部分。断言帮我们自动判断请求的成功与否。JMeter中支持多种格式的断言，可以在断言元件中添加。
1．响应断言
响应断言是对请求、响应数据（包含请求头、响应头数据）进行的一种基本断言。添加方法为在线程组上点击右键，选择断言，选择响应断言即可。如图1.47所示。
图1.47 JMeter 响应断言-包含指定文本
如上图，要断言响应体数据中包含指定文本，可以在响应断言中选择响应文本，选择包含，填写要包含的文本（如“登录成功”），并可以自定义该条断言失败时的消息内容。
响应文本的断言支持使用正则表达式匹配，如图1.48所示。
图1.48 JMeter 响应断言-正则表达式
如上图，选择响应文本，选择匹配，填写相应文本应匹配的正则表达式即可。

2．JSON响应断言
对于JSON格式的响应，可以使用JSON断言验证其中指定的字段的值符合预期。添加方法为，右键点击线程组，点击断言，选择JSON断言即可。
JMeter中JSON断言中使用JSONPath语法来提取响应的指定字段。我们可以首先利用结果树元件来验证我们的JSONPath语法是否能提取到对应字段。如图1.49所示。
图1.49 JMeter 结果树-JSONPath验证
发送完请求，在结果树中选择“JSON Path Tester”，在“JSON Path
Expression”中输入JSONPath表达式，如“$.form.name”。“$”代表JSON响应的根节点。使用“.”取下级节点，如果是Array数组，可以使用“[N]
”来取第N项数据。
点击Test按钮验证能获取到指定的数据后。在JMeter中对应的请求下添加JSON断言，输入JSONPath表达式。勾选“Additionally assert
value”，输入“Expected Value”期望结果即可。如图1.50所示。
图1.50 JMeter 添加JSONPath断言
注意如果不勾选Additionally assert value则只要能根据该JSONPath表达式匹配出有值即视为通过。勾选后可以断言JSONPath表达式对应字段的值。
如果要对多个字段进行断言，要添加多个JSON断言研究。
点击发送请求，即可在结果树中查看请求通过与否。

3．XPath断言
XPath即XML路径选择语言，适用于XML和HTML格式的文本。对于XML或HTML格式的响应数据，我们可以使用XPath提取节点进行断言。
添加方式为，线程组上点击右键，点击断言，选择XPath断言即可。
同样，对于XPath，我们可以使用结果树先来验证XPath表达式。如图1.51所示。
图1.51 JMeter 结果树-XPath验证
发送请求后，在结果树中选择XPath Tester，在XPath query中输入对应的XPath表达式，点击Test即可。XPath使用“/”表示根路径，“//”表示任意路径，后面h1是标签名。
在验证完XPath表达式后，在对应的请求下添加XPath断言，填写指定的XPath表达式即可，如图1.52所示。

图1.52 JMeter 添加XPath断言
以上XPath断言只能验证响应中该XPath表达式能匹配出结果。

4．Bean Shell断言
Bean Shell是一套符合Java语法的脚本语言，同过Bean Shell可以使用代码，灵活的对响应数据进行各种操作及判断。
Bean Shell中可以通ResponseCode、ResponseHeaders及prev.getResponseDataAsString()
来获取String格式的状态码、响应头以及响应体数据。通过if判断进行断言，断言中通过设置变量Failure=false或Failure=true来设置断言通过或失败，同时还可以通变量FailureMessage设置失败原因。
添加方式为，线程组上点击右键，点击断言，选择Bean Shell断言即可，如图1.53所示。
图1.53 JMeter Bean shell断言

### 1.7.4  关联

关联，指将上一个接口的响应数据中的某个值用于下一个接口，又称为接口依赖。关联包含两个部分的操作，一是上一个接口响应数据变量的提取和保存，二是下一个接口中使用参数化变量使用提取和存储的变量值。
以百度OCR接口为例。该接口首先需要根据个人的id秘钥获取token值，以供百度OCR接口使用。

1. 在JMeter中添加一个逻辑控制器，简单控制器元件，在下面添加两个HTTP请求，如图1.54所示。
   图1.54 JMeter 发送所依赖请求
2. 在第一个接口获取百度token请求下添加后置处理器元件JSON提取器，使用JSONPath提取变量并设置保存的变量名为access_token。如图1.55所示。
   图1.55 JMeter 使用JSON提取器提取关联变量
3. 在下一个接口百度orc的路径中使用${access_token}来使用上面保存的变量。如图1.56所示。
   图1.56 JMeter 使用关联变量
   填写完其他请求数据，点击发送即可在结果树中查看两个请求状态。

### 1.7.5  数据驱动

对于同一个请求，我们经常要使用不同的数据进行测试。此时可以使用数据驱动的方式进行处理。
JMeter中默认支持使用CSV文件进行数据驱动，添加方法为在线程组上点击右键，点击前置处理器，选择CSV配置元件即可。

1. 添加CSV配置元件并选择数据文件，如图1.57所示。
   图1.57 JMeter 添加CSV数据文件
   CSV数据文件不需要有标题行，要在CSV配置元件中声明每一列对应的编码名，以英文逗号隔开，如name,password，分隔符根据文件中的分割符设置，这里是英文逗号。
2. 在HTTP请求中使用${name}和${password}来参数化变量。如图1.58所示。
   图1.58 JMeter 使用CSV数据文件变量
3. 修改线程组迭代次数为数据文件数据行数。点击运行，即可在在结果树中查看每一组数据的请求结果。

### 1.7.6  压力测试及生成报告

JMeter一般用于压力测试，相对于调试接口请求，压力测试时的配置稍有不同。

#### 1．请求设置

压力测试时HTTP请求一般要不勾选“跟随重定向”和“使用Keep Alive”，即如果接口进行的重定向，只请求当前接口，并且不使用Keep
Alive，每次请求后断开TCP连接，以便下次请求模拟新用户重新建立TCP连接发送请求。如图1.59所示。
图1.59 JMeter 去除重定向和Keepalive
为避免大量的请求日志可以在结果树中勾选“仅错误日志”，如图1.60所示。
图1.60 JMeter 仅输出错误日志

#### 2．线程组设置

压测时需要根据实际的业务需求如并发量，压测时间等来设置线程组参数。如以200并发压测5分钟。设置如图1.61所示。
图1.61 JMeter 设置线程组-并发量和持续时间
Ramp-Up即准备时间，填0即可（同时启动200个线程），循环次数勾选永远，同时勾选调度器，持续时间填写300秒。

#### 3．GUI运行

设置完请求、断言和线程组后，即可开始压测。压测分为GUI使用图形界面运行和非GUI使用命令行运行两种。一般推荐使用非GUI模式运行，客户机性能会更好一点。
如果使用GUI运行，可以在请求中添加监听器元件中的聚合报告，如图1.62所示。
图1.62 JMeter GUI运行-查看聚合报告
在聚合报告元件中可填写报告保存的路径，可以使用csv格式。
点击运行便可在聚合报告中查看到实时的平均响应时间，出错率和吞吐量等数据。

#### 4．生成报告

聚合报告生成的csv结果数据文件要经过转换才能生成漂亮的HTML格式测试报告。选择菜单栏Tools中的Generate HTML
report报告工具。选择聚合报告的结果文件，JMeter当前用户配置(bin目录下的user.properties文件）以及报告输出目录。点击Generate
report按钮生成报告，如图2.53所示。
图1.63 JMeter 生成HTML报告
生成成功后便可以打开输出目录中的index.html，查看本次压测的结果报告，如图2.54所示。
图1.64 JMeter HTML压测报告

## 1.8  小结

本章讲解了接口及接口测试相关概念和流程、网络基础知识以及HTTP协议。本章还接口相关测试工具的使用。抓包是我们在定位问题时需要具备的基本能力，根据请求参数和实际返回结果来界定前端还是后端的问题。Postman是一款非常优秀的接口调试工具，在编写自动化接口测试脚本之前，一般要使用Postman先调试通过。如果在接口功能测试完成后，需要测试接口的性能，可以使用JMeter。
